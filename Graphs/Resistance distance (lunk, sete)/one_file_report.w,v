head	1.27;
access;
symbols;
locks
	lunk:1.27; strict;
comment	@# @;


1.27
date	2024.07.15.12.59.36;	author lunk;	state Exp;
branches;
next	1.26;

1.26
date	2024.07.14.11.18.48;	author sete;	state Exp;
branches;
next	1.25;

1.25
date	2024.07.14.10.53.04;	author lunk;	state Exp;
branches;
next	1.24;

1.24
date	2024.07.14.09.51.03;	author sete;	state Exp;
branches;
next	1.23;

1.23
date	2024.07.14.09.43.31;	author lunk;	state Exp;
branches;
next	1.22;

1.22
date	2024.07.14.07.52.08;	author lunk;	state Exp;
branches;
next	1.21;

1.21
date	2024.07.14.07.31.29;	author lunk;	state Exp;
branches;
next	1.20;

1.20
date	2024.07.14.07.29.43;	author lunk;	state Exp;
branches;
next	1.19;

1.19
date	2024.07.14.06.46.27;	author lunk;	state Exp;
branches;
next	1.18;

1.18
date	2024.07.14.06.41.49;	author sete;	state Exp;
branches;
next	1.17;

1.17
date	2024.07.14.04.43.24;	author sete;	state Exp;
branches;
next	1.16;

1.16
date	2024.07.14.04.24.25;	author lunk;	state Exp;
branches;
next	1.15;

1.15
date	2024.07.14.04.09.26;	author lunk;	state Exp;
branches;
next	1.14;

1.14
date	2024.07.14.04.05.34;	author sete;	state Exp;
branches;
next	1.13;

1.13
date	2024.07.14.03.38.28;	author lunk;	state Exp;
branches;
next	1.12;

1.12
date	2024.07.14.03.18.40;	author lunk;	state Exp;
branches;
next	1.11;

1.11
date	2024.07.14.03.17.28;	author sete;	state Exp;
branches;
next	1.10;

1.10
date	2024.07.14.03.16.00;	author sete;	state Exp;
branches;
next	1.9;

1.9
date	2024.07.14.03.14.02;	author lunk;	state Exp;
branches;
next	1.8;

1.8
date	2024.07.14.02.35.33;	author lunk;	state Exp;
branches;
next	1.7;

1.7
date	2024.07.14.02.32.53;	author sete;	state Exp;
branches;
next	1.6;

1.6
date	2024.07.14.02.30.06;	author lunk;	state Exp;
branches;
next	1.5;

1.5
date	2024.07.14.01.21.14;	author lunk;	state Exp;
branches;
next	1.4;

1.4
date	2024.07.13.06.31.44;	author lunk;	state Exp;
branches;
next	1.3;

1.3
date	2024.07.12.11.38.49;	author lunk;	state Exp;
branches;
next	1.2;

1.2
date	2024.07.12.11.28.31;	author sete;	state Exp;
branches;
next	1.1;

1.1
date	2024.07.12.11.19.44;	author lunk;	state Exp;
branches;
next	;


desc
@old
@


1.27
log
@new gost
@
text
@\documentclass[utf8x]{G7-32}
\usepackage[T2A]{fontenc} % Кодировка шрифта
\usepackage{rcs}
\RCS $Revision: 1.3 $
\RCS $Date: 2024/07/12 11:38:49 $
\RCS $Author: lunk $

\usepackage{graphicx} % Для вставки изображений
\usepackage{amsmath} % Для использования математических формул
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{cancel}
\usepackage{tikz}
\usepackage{amsfonts} % Для использования математических символов и шрифтов
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage[strings]{underscore}
\usepackage{fancyvrb}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{corollary}[theorem]{Следствие}
\newtheorem{proposition}[theorem]{Утверждение}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Определение}
\newtheorem{example}[theorem]{Пример}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Замечание}




\include{preamble.inc}
\include{listings.inc}

\include{macros.inc}

\gosttitle{Gost7-32}

\NirOrgLongName{\textsc{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\\
	РОССИЙСКОЙ ФЕДЕРАЦИИ\\
	Федеральное государственное автономное\\
	образовательное учреждение высшего образования\\
	«Дальневосточный федеральный университет» \\
	ИНСТИТУТ МАТЕМАТИКИ И КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ\\
	ДЕПАРТАМЕНТ МАТЕМАТИЧЕСКОГО И КОМПЬЮТЕРНОГО\\
	МОДЕЛИРОВАНИЯ
	}}
%\NirBoss{Директор ООО "Рога и Копыта"}{И.И.Иванов} %% Заказчик, утверждающий НИР


\NirYear{2024}%% если нужно поменять год отчёта; если закомментировано, ставится текущий год
\NirTown{г. Владивосток,} %% город, в котором написан отчёт
% по проекту \No8550:

% \NirIsAnnotacion{АННОТАЦИОННЫЙ } %% Раскомментируйте, если это аннотационный отчёт

%\NirUdk{УДК \No 123132123}
%\NirGosNo{Регистрационный \No 123123}
%\NirReportName{Научно-технический отчет}
%\NirStage{Этап \No 1.1}{промежуточный}{"Обзор современного состояния торсионных наногенераторов"} %%% Этап НИР: {номер этапа}{вид отчёта - промежуточный или заключительный}{название этапа}
\Nir{Алгоритмическая теория графов}
\NirSubject{\textbf{"Случайные блуждания: связь с резистивным расстоянием"}} %%% Название НИР и генерация титульного листа
\NirFinal{}
\NirIsp{Руководитель темы}{Е.А. Нурминский}
%Revision: \RCSRevision, 
%Date: \RCSDate, 
%Author: \RCSAuthor  
\NirCode{Revision: \RCSRevision,
Date: \RCSDate,
Author: \RCSAuthor}
\begin{document}
\maketitle
\begin{executors}
\personalSignature{Вершинин Д.А.}{подпись}

\personalSignature{Пелагеев Д.И.}{подпись}
\end{executors}

\tableofcontents
\Defines % Список обозначений и сокращений в тексте
\begin{description}
	\item[Электрическая цепь] Набор электрических компонентов, таких как резисторы, конденсаторы и источники питания, соединённых проводниками для создания замкнутого пути, по которому может течь электрический ток.

	\item[Граф] Математическая структура, состоящая из вершин (узлов) $V$ и рёбер $E$, соединяющих пары вершин, используемая для моделирования различных систем и их взаимосвязей.

	\item[Вершина] Фундаментальный элемент в теории графов, представляющий объект или точку соединения в электрической цепи или другой сети. Также иногда называется узлом.

	\item[Ребро] Соединение между двумя вершинами графа, вес которого соответствует электрическому сопротивлению соединения в электрической цепи.

	\item[Смежные вершины] Две вершины называются смежными, если они соединены ребром. Если вершины $x$ и $y$ смежные, то это можно записать как $x\sim y$. Все смежные вершины для вершины $x$ обозначим, как $\sim x$.	

	\item[Резистивное расстояние] Cопротивление между двумя вершинами в графе, моделирующем электрическую цепь, когда все сопротивления заменены на единичные.

	\item[Законы Кирхгофа] Физические законы, описывающие сохранение электрического заряда в электрической цепи. Первый закон (Закон узлов) утверждает, что сумма токов, входящих в узел, равна сумме токов, выходящих из узла. Второй закон (Закон контуров) гласит, что сумма напряжений в любом замкнутом контуре цепи равна нулю.

	\item[Матрица смежности] Квадратная матрица, используемая для представления графа, где элементы указывают наличие или отсутствие рёбер между парами вершин.

	\item[Лапласиан] Квадратная матрица, вычисляемая на основе матрицы смежности графа, которая используется для анализа свойств графов.

	\item[Обратная матрица Лапласиана] Матрица, полученная при обращении Лапласиана графа, используемая для вычисления резистивного расстояния между вершинами графа.

	\item[Обращение матрицы] Операция, при которой для данной квадратной матрицы \(A\) находится такая матрица \(A^{-1}\), что произведение \(A \cdot A^{-1}\) равно единичной матрице. 

	\item[Случайное блуждание] Модель, описывающая случайное перемещение по вершинам графа, где вероятность перехода из одной вершины в другую определяется весами рёбер.

	\item[Сопротивление] Физическая величина, характеризующая способность проводника препятствовать прохождению электрического тока, измеряемая в омах (\(\Omega\)). Существует несколько способов расчета сопротивления:

		\begin{itemize}
		    \item \textbf{Закон Ома:} Сопротивление \(R\) можно определить как отношение напряжения \(U\) на проводнике к силе тока \(I\), протекающего через него: \(R = \frac{U}{I}\).
					        
   	            \item \textbf{Последовательное соединение резисторов:} Общее сопротивление \(R_{\text{сум}} \) для последовательного соединения резисторов определяется как сумма сопротивлений всех резисторов: \(R_{\text{сум}} = R_1 + R_2 + \ldots + R_n\).
							    
		    \item \textbf{Параллельное соединение резисторов:} Общее сопротивление \(R_{\text{п}} \) для параллельного соединения резисторов определяется как обратная величина суммы обратных значений сопротивлений всех резисторов: \(\frac{1}{R_{\text{п}}} = \frac{1}{R_1} + \frac{1}{R_2} + \ldots + \frac{1}{R_n}\).
						        
		\end{itemize}
	\item[Напряжение] Разность электрических потенциалов между двумя точками электрической цепи, определяющая способность источника энергии выполнять работу по перемещению заряда, измеряемая в вольтах (В). 

	\item[Сила тока] Количество электрического заряда, проходящего через поперечное сечение проводника за единицу времени, измеряемая в амперах (А).


\end{description}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:

%\subsection{Разработка программы для вычисления резистивного расстояния в графах с использованием Octave}
\frontmatter
%\chapter{Введение}
\chapter{Введение}
\label{cha:vvedenie}
Теория графов часто применяется для исследования электрических цепей. 
Одной ее из задач является нахождение сопротивления между двумя узлами электрической сети.
Эту задачу можно рассматривать в контексте теории графов, т.к. электрическую цепь можно моделировать с помощью связного графа, где вершинами графа являются узлы сети.
Два узла сети являются смежными, если между ними существует прямая связь. Это означает, что между этими узлами существует физическое соединение.
Такому соединению можно сопоставить ребро графа, где его весом является электрическая проводимость между двумя узлами сети, взятых изолированно от остальной сети. 

С введением графовой интерпретации можно задать метрику для нахождения 
расстояния между двумя произвольными вершинами графа -- резистивное расстояние\cite{RD}. 
Резистивное расстояние между двумя вершинами простого связного графа G равно сопротивлению между двумя 
узлами электрической цепи, построенной путем замены сопротивления всех связей сети на сопротивление в 1 Ом.
В таком случае вес каждого ребра будет равен единице.
В то же время, для электрической цепи применим первый закон Кирхгофа : "Алгебраическая сумма токов в узле электрической цепи равна нулю". 

Связь между Законами Кирхгофа и резистивным расстоянием начали исследовать Douglas J. Klein и  M. Randic \cite{RD2} несколько десятилетий назад. 

В данной работе рассматривается модель электрической цепи, представленной в виде графа, где вершины графа соответствуют узлам электрической сети, 
а вес ребра графа — сопротивлениям между этими узлами, взятыми изолированно от основной сети. 
Главной целью является нахождение резистивного расстояния между двумя произвольными вершинами графа. 
Это расстояние эквивалентно сопротивлению между соответствующими узлами в электрической цепи. 
Модель позволяет использовать математические методы теории графов для анализа электрических цепей, что упрощает вычисления и интерпретацию результатов. 

Прикладной задачей является разработка алгоритма для вычисления резистивного расстояния, 
что открывает возможности для применения этой модели в различных областях, включая оптимизацию маршрутов и анализ сложных сетей.

Существует также тесная связь резистивного расстояния с методом случайных блужданий.
Этот метод основывается на предположении, что время перемещения по каждому ребру равно единице, а выбор следующей
вершины происходит независимо с равной вероятностью для всех соседей текущей вершины.
Случайное блуждание моделирует поведение тока в электрических цепях.
\mainmatter
\chapter{Теоретические аспекты электрических сетей}
Стоит отметить, что существует два вида закона Ома: линейный и нелинейный. 

Линейный закон Ома утверждает, что ток через проводник прямо пропорционален напряжению, приложенному к нему, при условии, 
что температура и другие физические условия остаются постоянными. Это выражается формулой:
$$I = \frac{U}{R},$$
где $I$ -- ток (в амперах, А), $U$ -- напряжение (в вольтах, В), $R$ -- сопротивление (в омах, Ом).

Нелинейный закон Ома описывает материалы и устройства, у которых нет прямой зависимости тока от напряжения. 
В таких случаях ток может изменяться при изменении напряжения или сопротивления нелинейно.
Формула нелинейного закона Ома часто значительно сложнее, чем линейный закон, и зависит от специфики материала или компонента. 
Для описания таких зависимостей обычно применяют эмпирические формулы.

В работе рассматривается только линейный закон Ома.
\section{Физические определения}
\begin{definition}[Ток]
	Ток $i_{xy}$ из вершины $x$ в $y$ графа $G$ определяется на парах смежных вершин так, что:
	\begin{equation}\label{tok1}
	i_{xy} = - i_{yx}
	\end{equation}
	Ток $i_{xy}$ определяется уравнением:
	\begin{equation}\label{tok2}
	\sum_y^{\sim x} i_{xy} = I\cdot \delta_{xa} - I\cdot \delta_{xb}, \ \forall x \in V(G)
	\end{equation}
	где сумма берется по всем $y\in V(G)$, смежным с вершиной $x$; $\delta_{xy}$ -- символ Кронекера. 
\end{definition}
Формула (\ref{tok2}) описывает сумму токов, входящих в вершину $x$. 
Величина $I\delta_{xa}$ равна $I$, если $x=a$ (источник), и 0 -- в противном случае. 
Аналогично, $I\delta_{xb}$ равно $I$, если $x=b$ (сток), и 0 -- в противном случае. 
Таким образом, $I$ представляет собой величину чистого тока, выходящего из источника $a$ и входящего в сток $b$.
Это уравнение известно как закон Кирхгофа для тока (в случае одного источника и одного стока).

\begin{definition}[Физический ток]
	Ток называют физическим \cite{RD2}, если существует потенциал $v$ на вершинах графа $G$ такой, что:
	\begin{equation}\label{tok3}
	i_{xy}\cdot r_{xy} = v_x - v_y, \ \forall x,y \in E(G),
	\end{equation}
	где $r_{xy} \equiv r_{yx}$, $v_x$ - потенциал на узле $x$, $v_y$ - потенциал на узле $y$. 
\end{definition}

Потенциал известен как напряжение (аналог давления в гидравлике), а уравнение (\ref{tok3}) также известно как закон Ома.
Для тока в графе $G$ существование такого потенциала может быть показано через второй закон Кирхгофа для цепей:
\begin{equation}\label{tok4}
	\sum_{x\sim y}^C i_{xy}r_{xy} = 0, \ \forall C
\end{equation}
где сумма берется по всем ребрам контура $C$ в графе $G$, а ток $i$ из упорядоченной последовательности токов контура $C$. 

\section{Нормированное пространство}
В соответствии с графом $G$ можно определить нормированное пространство с ортонормированным базисом, элементы которого сопоставлены с вершинами графа $G$.
Такие базисные вектора определяется как $\mathbf{e}, \mathbf{e}\in V(G)$. 
Размерность этого пространства равна количеству вершин в графе $G$.
В этом пространстве представлены несколько матриц (линейных операторов).
\begin{definition}[Матрица инцидентности]
	Матрицей инцидентности называется матрица, элементы которой задаются следующим образом:
	\begin{equation}\label{tok5}
	A_{xy} = 
	\begin{cases}
		1/r_{xy}, & x  \sim y\\
		0, & otherwise
	\end{cases} \ x,y \in V(G),
	\end{equation}
Элементы матрицы инцидентности $A$ можно также получить через произведение вектора $\mathbf{x}^T$, матрицы $A$ и вектора $\mathbf{y}$
$$A_{xy} = \mathbf{x}^T A \mathbf{y},$$
где $\mathbf{x}$ - вектор, 
в котором элемент с номером $x$ равен 1, а остальные 0; 
$\mathbf{y}$ - вектор,в котором элемент с номером $y$ равен 1, а остальные 0;
$A$ - матрица инцидентности графа $G$.
\end{definition}
При установлении единичных сопротивлений в цепи, матрица \( A \) сводится к матрице смежности графа \( G \).

\begin{definition}[Матрица степеней]
	Матрица $\Delta$,  элементы которой задаются следующим образом:
	\begin{equation}\label{tok6}
		\Delta_{xy} = \delta_{xy}\sum_z^{\sim x}1/r_{xz}, \ x,z \in V(G)
	\end{equation}
	где суммирование происходит по вершинам $z$, которые смежны с $x$, называется матрицей степеней вершин. 
\end{definition}
Элементы матрицы степеней $\Delta$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $\Delta$ и вектора $\mathbf{y}$
$$\Delta_{xy} = \mathbf{x}^T \Delta \mathbf{y},$$
где $\mathbf{x}$ - вектор,в котором элемент с номером $x$ равен 1, а остальные 0;
$\mathbf{y}$ - вектор,в котором элемент с номером $y$ равен 1, а остальные 0;
$\Delta$ - матрица степеней графа $G$.

Далее большую роль сыграет матрица под названием Лапласиан, которая задаётся через разность $\Delta - A$. 

\begin{lemma}[О собственных значениях]
	Лапласиан имеет неотрицательные собственные значения, минимум одно из которых ноль. 
	Если граф $G$ связный, то соответствующий собственный вектор (с точностью до скалярного множителя) равен:
	\begin{equation}\label{tok7}
		\mathbf{\phi} \equiv \sum_x \mathbf{x}, \ \forall x \in V(G)
	\end{equation}
\end{lemma}

Для уменьшения размера работы доказательство опускается. Оно представлено в \cite{RD2} см. 86 стр. 

\begin{corollary}
	По условиям леммы, Лапласиан имеет как минимум одно собственное значение равное нулю. 
	Следовательно, он не является обратимым в привычном смысле.
	Однако в подпространстве, ортогональном к $\mathbf{\phi}$, он имеет псевдообратную матрицу, которая задаётся следующим образом:
	$$(\Delta - A)^+=((\Delta - A)^T(\Delta - A))^{-1}(\Delta - A)^T$$
\end{corollary}

\section{Резистивное расстояние}

\begin{lemma}[О токе]
	Физический ток в связном графе $G$ из вершины $a$ в вершину $b$ существует, является единственным и определяется следующим образом:
	\begin{equation}\label{tok10}
		i_{xy} = \frac{I}{r_{xy}} ((\mathbf{x -y} )^T(\Delta - A)^+( \mathbf{ a-b})),
	\end{equation}
	где $\mathbf{a, b, x ,y}$ - векторы, в которых элементы с номерами $a,b,x,y$ (соответственно) равны 1, а остальные элементы --  0;
	$(\Delta - A)^+$ - псевдообратная матрица Лапласиана.
\end{lemma}

\begin{proof}
	Для доказательства, подставим (\ref{tok3}) в (\ref{tok2}) и получим:
	\begin{equation}\label{tok11}
		\sum_y^{\sim x}\frac{1}{r_{xy}} \{v_x - v_y\} = I\delta_{xa} - I\delta_{xb}
	\end{equation}
	Используя (\ref{tok6}) и (\ref{tok5}), получим:
	\begin{equation}\label{tok12}
	\mathbf{x}^T \Delta \mathbf{x} v_x - \sum_y \mathbf{x}^T A \mathbf{y} v_y = I (\mathbf{x} \cdot (\mathbf{ a -b})),
	\end{equation}
	где $\mathbf{a, b, x ,y}$ - векторы, в которых элементы с номерами $a,b,x,y$ (соответственно) равны 1, а остальные 0.

	Теперь $\forall x \in V(G)$ и т.к. $x$ и $y$ сопостовимы, перепишем (\ref{tok12}) как:
	$$\Delta \sum_x \mathbf{x} v_x - A \sum_x \mathbf{x} v_x = I (\mathbf{a-b})$$
	\begin{equation}\label{tok13}
	(\Delta - A)\sum_x v_x \mathbf{x}  = I(\mathbf{a - b}). 
	\end{equation}
	Тогда, согласно лемме о собственных значениях, (\ref{tok13}) можно переписать как: 
	\begin{equation}\label{tok14}
	\sum_x v_x \mathbf{x} = I(\Delta - A)^+ (\mathbf{a-b}), 
	\end{equation}
	Это непосредственно приводит к формуле нашей теоремы, тем самым устанавливая уникальность этих различий. 
	Для нахождения разности потенциалов между парой вершин $x,\ y$ нужно из элемента вектора $\sum_x v_x \mathbf{x}$ с номером $x$ вычесть элемент с номером $y$, что дает нам:
	\begin{equation}\label{tok15}
	v_x - v_y = I((\mathbf{x - y})^T(\Delta - A)^+ (\mathbf{a-b}))
	\end{equation}
	Тогда, закон Ома (\ref{tok3}) дает формулу леммы, единственность $I$ и его существование:
	\begin{equation}\label{tok16}
        v_x - v_y = i_{xy} r_{xy} \Rightarrow i_{xy} = \frac{v_x - v_y}{r_{xy}} = \frac{I}{r_{xy}} ((\mathbf{x - y})^T(\Delta - A)^+ (\mathbf{a-b}))
        \end{equation}
\end{proof}

Разность потенциалов между двумя точками, как видно из закона Ома, прямо пропорциональна $i$. 
При выборе $x=a$ и $y=b$, этот коэффициент пропорциональности называется резистивным расстоянием $\Omega_{ab}$ между $a$ и $b$. 
Таким образом, мы получаем основной результат этого раздела:

\begin{theorem} [О резистивном расстоянии]
	Для физического тока из $a$ в $b$ в графе $G$ резистивное расстояние $\Omega_{ab}$ равно:
	\begin{equation}
		\Omega_{ab} = (\mathbf{a-b})^T(\Delta - A)^+(\mathbf{a-b})
	\end{equation}
\end{theorem}


\begin{theorem}[Сопротивление эквивалентно расстоянию]
		Формально определим сопротивления как расстояние.
		Под расстоянием на графе $G$ мы понимаем отображение $\rho$ из декартова произведения $V(G)\times V(G)$ в вещественные числа, удовлетворяющее следующим аксиомам:
		\[\rho(a,b) \ge 0,\]
		\[\rho(a,b) =0 \Leftrightarrow a =b,\]
		\[\rho(a,b) = \rho(b,a),\]
		\[\rho(a,x) = \rho(x,b) \ge \rho(a,b)\]
\end{theorem}
Доказательство приведено в \cite{RD2} см. 89 стр.



\chapter{Теоретические основы случайных блужданий}
\label{cha:theory}

Случайное блуждание на графе \(G\) представляет собой процесс, при котором на каждом шаге изменяется состояние случайного процесса, заключающееся в перемещении из текущей вершины в одну из соседних вершин, выбранную независимым образом с равной вероятностью. 

Цель изучения случайных блужданий заключается в их универсальности и применимости к широкому спектру задач в науке и технике. 
Они предоставляют мощные инструменты для моделирования, анализа и решения сложных проблем, связанных с неопределенностью и случайностью.

Рассмотрим однородное случайное блуждание, при котором вероятность перехода из вершины $x$ в любую соседнюю вершину одинакова и равна \(1/d(x)\), 
где $d(x)$ - степень вершины $x$. 

Для начала определим сценарий, который будет полезен в доказательстве нескольких теорем.

\begin{definition}[Сценарий А]
	Подадим на каждый узел сети ток, равный количеству связей этого узла ($d(x)$). 
	Выберем узел $y$ и получим из него ток, равный $2m = \sum_x d(x)$, где $m$ - количество связей в сети.  
	Выбор количества тока обусловлен тем фактом, что сумма количества связей каждой вершины даст число, равное удвоенному количеству связей в цепи. 
\end{definition}

\begin{definition}[Время попадания]
	Для любых двух вершин $x$ и $y$  графа $G$ время попадания (hitting time, $H_{xy}$) определяется, 
	как мат ожидание или же среднее количество шагов (steps) случайного блуждания, 
	необходимое для достижения вершины $y$ из вершины $x$.
	$$H_{xy} = {\mathbb{E}} [steps]$$
\end{definition}

\begin{definition}[Время возвращения]
	Время возвращения (commute time) $C_{xy}$ между двумя вершинами $x$ и $y$ в графе $G$ равно 
	сумме времени попадания из вершины $x$ в вершину $y$ и времени попадания из  $y$ в $x$.
	$$C_{xy} = H_{xy} + H_{yx}$$
\end{definition}

\begin{theorem}[Время первого попадания]
	При сценарии А
	разность потенциалов $\phi_{xy}$ между узлами $x$ и $y$ равна среднему времени попадания в вершину \(y\) из вершины \(x\) ($H_{xy}$):

\begin{equation}\label{phi}
    \phi_{xy} = H_{xy}
\end{equation}

\end{theorem}

\begin{proof}
Выберем начальный узел $x$ и конечный узел $y$.
В соответствии со вторым законом Кирхгофа, законом Ома и тем фактом, что все сопротивления проводников равны единице, имеем следующее:

\begin{equation}\label{d_x_1}
	d(x) = \sum_{z}^{\sim x} (\phi_{xy} - \phi_{zy})
\end{equation}
	Разложим сумму разности на разность сумм.
	Заметим, что  $\phi_{xy}$ не зависит от индекса z. 
	Следовательно, суммирование $\phi_{xy}$ будет производиться столько раз, какую степень имеет вершина $x$. Тогда,(\ref{d_x_1}) можно переписать:

\begin{equation}\label{d_x_2}
	d(x) = d(x) \cdot \phi_{xy} - \sum_{z}^{\sim x} \phi_{zy}
\end{equation}

	Решая уравнение, относительно $\phi_{xy}$, получим следующее:
	\begin{equation}\label{d_x_3}
		\phi_{xy} = 1 + \frac{1}{d(x)} \sum_{z}^{\sim x} \phi_{zy}
	\end{equation}
	Введем дополнительное условие для случая $x=y$:

\begin{equation}\label{phi_(xy)}
	\phi_{xy} = 
	\begin{cases} 
		0 & x = y \\
		1 + \frac{1}{d(x)} \sum\limits_{z}^{\sim x} \phi_{zy} &  x \neq y
	\end{cases} 
\end{equation}

	Из курса теории вероятности очевидно, что среднее время попадания из вершины $x$ в вершину $y$ ($H_{xy}$) 
	равно среднему времени попадания из смежных с $x$ вершин до вершины $y$ плюс один (один шаг до смежной вершины). 

\begin{equation}\label{H_xy}
	H_{xy} = 1 + \frac{1}{d(x)} \sum_{z}^{\sim x} H_{zy}
\end{equation}


	Установим условие для $x=y$
\begin{equation}\label{H_(xy)}
	H_{xy} = 
	\begin{cases} 
		0 & x = y \\
		1 + \frac{1}{d(x)} \sum\limits_{z}^{\sim x} H_{zy} &  x \neq y
	\end{cases} 
\end{equation}
	Заметим, что формулы (\ref{phi_(xy)}) и (\ref{H_(xy)}) идентичны, т.к. являются линейными системами с единственным решением.
	Следовательно, получим:

	\begin{equation}\label{H_xy_end}
		H_{xy} = \phi_{xy}
	\end{equation}

\end{proof}


Введём следующие определения.
\begin{definition}[Сценарий B]
	Сценарий B является схожим со сценарием A, за исключением того, что стоком будет являться вершина $x$. 
	Обозначим разность потенциалов сценария B за $\phi_{yx}'$, где $x,y \in V(G)$.

	Используя теорему о времени первого попадания, сценарий B можно записать, как
	$$\phi_{yx}' = H_{yx} $$
\end{definition}
\begin{definition}[Сценарий C]
	Подадим ток, равный $2m$ на узел $x$, где $m$ - количество связей цепи.
	Стоком будут являться все узлы сети.
	Обозначим разность потенциалов сценария C за $\phi_{xy}''$, где $x,y \in V(G)$.

	Данный сценарий является обратным к сценарию B, т.к. изменение затронуло направление тока в сети.
	Поэтому мы получили:
	$$\phi_{xy}''=\phi_{yx}' = H_{yx} $$
\end{definition}

Основываясь на этих определениях и теореме о времени первого попадания докажем следующую теорему.
\begin{theorem}[Время возвращения]

	Время возвращения из вершины $x$ через вершину $y$ графа $G$ равно удвоенному количеству ребер (\(m\)) графа $G$,
	умноженному на сопротивление \(R_{xy}\)\cite{3}.

\begin{equation}\label{C_xy}
C_{xy} = 2mR_{xy}
\end{equation}

\end{theorem}

\begin{proof}
	Для доказательства этой теоремы используем сумму сценариев A и C. 
	Другими словами, подадим ток $2m$ на вершину $x$ и получим его с вершины $y$.
	Обозначим разность потенциалов в этом случае за $\phi_{xy}'''$
	$$\phi_{xy} '''= \phi_{xy} + \phi_{yx}''$$
	По теореме о времени попадания и исходя из определения сценариев A и C получим:
	$$\phi_{xy} '''= H_{xy} + H_{yx}$$
	Заметим, что $\phi_{xy}'''$ является разностью потенциалов для перемещения тока $2m$ из узла  $x$ в узел $y$. 
	Используя закон Ома имеем:
	$$\phi_{xy}''' = 2mR_{xy}.$$
	Тогда получаем 
	\begin{equation}\label{C_xy_end}
		H_{xy} + H_{yx} = 2mR_{xy} \Rightarrow C_{xy} =  2mR_{xy}
	\end{equation}

\end{proof}

\chapter{Программа для расчета резистивного расстояния с помощью законов Кирхгофа}
Для разработки программы был выбран язык программирования Octave\cite{octv1},
специально предназначенный для математических вычислений и являющейся бесплатной альтернативой
MATLAB\cite{matlb}.

Основные задачи заключались в следующем:

\begin{enumerate}
	\item Обеспечение универсальности (выбор файла с матрицей смежности графа, а также начального и конечного узлов).
	\item Расчет резистивного расстояния между двумя произвольными вершинами графа.
	\item Измерение времени выполнения программы.
\end{enumerate}

Cкрипт {\tt mainKirg} на языке Octave, приведенный ниже.

@@d mainKirg @@{
@@< start-up: input and prelimnary data check  @@>
@@< compute main part @@>
@@< compute resistance-distatnce @@>
@@< display results @@>
@@}
@@o mainKirg.m @@{@@< mainKirg @@>@@}
\section{Ввод и предварительная проверка данных}

Начальный фрагмент определяет исходные данные задачи.
Одним из ключевых аспектов являлась универсальность использования, что требовало реализации ввода имени файла для чтения и номеров узлов.

Здесь проверяется количество переданных параметров.
В случае если их недостаточно, программа завершает работу с сообщением об ошибке.
Далее происходит парсинг параметров: первый — имя файла, второй — начальный узел, третий — конечный узел.
После происходит проверка введенных параметров на корректность.
В случае неправильных данных вызывается ошибка с пояснением.
Запускается таймер выполнения программы.
В случае, если переданный файл уже обрабатывался, данные загрузятся из сохранённого файла.
Иначе выполняется блок кода "compute main part".

@@d start-up: input and prelimnary data check  @@{
args = argv();
if numel(args) < 3
	error('Необходимо указать имя файла с матрицей смежности и', 
		'номера двух узлов.');
end
filename = args{1};

a = str2double(args{2});
b = str2double(args{3});
if isnan(a) || isnan(b) || a <= 0 || b <= 0 
	error('Номера узлов должны быть положительными целыми ',
		'числами.');
endif

tic;
[~, name, ~] = fileparts(filename);
pseudo_inverse_filename = [name, '_L_plus.mat'];

if exist(pseudo_inverse_filename, 'file') == 2
    	load(pseudo_inverse_filename, 'L_plus');
    	disp(['Псевдообратная матрица Лапласа загружена из файла ', 
		pseudo_inverse_filename, '.']);
	n = size(L_plus, 1);
@@}

\section{Основные расчеты}
Этот блок отвечает за тяжеловесные расчеты программы.

Cчитывается матрица смежности из указанного файла.
Подсчитывается количество вершин.
Вычисляются степени вершин, и создается диагональная матрица степеней.

Затем вычисляется матрица Лапласиана.
Происходит проверка корректности вычисления псевдообратной матрицы.
Вычисляется псевдообратная матрица Лапласиана.
Результат вычислений записывается в специальный файл.
Считывание псевдообратной матрицы из этого файла позволит сократить время расчёта при очередном запуске программы с той же матрицей смежности.
@@d compute main part  @@{
else
	A = dlmread(filename);
	n = size(A, 1);

	
	D = diag(sum(A, 2));
	L = D - A;
	if rank(L) < n-1
		error('Матрица Лапласиана не имеет полного ранга.');
	end
	L_plus = pinv(L);
	save(pseudo_inverse_filename, 'L_plus');
	disp(['Псевдообратная матрица Лапласа вычислена и ',
		'сохранена в файл ', pseudo_inverse_filename, '.']);
end
@@}
\section{Расчет разницы потенциалов}
Проверяется, что указанные узлы существуют в матрице.

Создается результирующий вектор h и производится расчет резистивного расстояния.
Для оптимизации программы эти действия записаны в одну строчку.
@@d compute resistance-distatnce @@{
if a > n || b > n
	error('Номера узлов выходят за пределы размерности ',
		'матрицы.');
endif

answer = (L_plus(a, a) - L_plus(b, a)) - (L_plus(a, b) - 
	L_plus(b, b));
@@}
\section{Вывод результата}

Остановка таймера выполнения и вывод результата:
@@d display results @@{
elapsed_time = toc;
disp("===========================================================");
disp(['Резистивное расстояние между узлами ', num2str(a), ' и ',
	 num2str(b), ': ', num2str(answer)]);
disp(['Время выполнения программы: ', num2str(elapsed_time), 
	' секунд']);
@@}

\chapter{Тестирование программы}

Программа была протестирована на различных графах в три этапа:
\begin{enumerate}
	\item Проверка правильности работы алгоритма на малых графах (до 5 вершин, заполненность 100\%).
	\item Тестирование на графах средних размеров (100-600 вершин, заполненность 90\%).
	\item Тестирование на больших графах (1000 и более вершин, заполненность 25-90\%).
\end{enumerate}
Данные для тестирования использовались без подгрузки предрасчитанной псевдообратной матрицы.

\section{Результаты тестирования}
\begin{itemize}
	\item Малые графы: алгоритм выдает решение менее чем за сотую долю секунды.
	\item Средние графы: время выполнения менее полусекунды для графов с количеством вершин менее 500. При 500-600 вершинах расчет занимает 3.5 секунды.
	\item Большие графы: для графа с 1000 вершинами и заполненностью 90\% расчет занимает 6.5 секунд. Граф с 3000 вершин и заполненностью 25\% рассчитывается за 500 секунд. Больше данных изображено на Рис. 4.1
\end{itemize}
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			width=\textwidth,
			height=0.6\textwidth,
			xlabel={Количество вершин},
			ylabel={Время работы программы},
			xlabel style={yshift=-10pt},
			tick label style={font=\small, rotate=45, anchor=east}
			]
			\addplot coordinates {
				(5,0.01) (100,0.013) (300, 0.3) (600,3.7) (1000, 6.5) (1500, 70) (2000, 142) (2500, 333) (3000, 500)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения программы от количества вершин в графе}
\end{figure}

Основное время выполнения программы приходится на вычисление псевдообратной матрицы (сложность $O(n^3)$). 
Поэтому, время выполнения увеличивается на три порядка при увеличении размера графа в 10 раз. 


\chapter{Реализация программы случайного блуждания}

\section{Переменные}
\subsection{Входные переменные}

\begin{itemize}
    \item \texttt{adj} - матрица смежности графа.
    \item \texttt{start} - индекс начального узла.
    \item \texttt{end_} - индекс конечного узла.
    \item \texttt{num_sim} - количество тестов.
\end{itemize}

\subsection{Выходные переменные}

\begin{itemize}
    \item \texttt{fht} - вектор, содержащий время первого попадания в конечный узел для каждого теста.
    \item \texttt{ct} - вектор, содержащий время полного обхода графа для каждого теста.
    \item \texttt{cmt} - вектор, содержащий время перемещения от начального узла к конечному и обратно для каждого теста.
    \item \texttt{mfht} - среднее время первого попадания в конечный узел.
    \item \texttt{mct} - среднее время полного обхода графа.
    \item \texttt{mcmt} - среднее время перемещения от начального узла к конечному и обратно.
    \item \texttt{eff_res} - сопротивление графа, рассчитанное как среднее время перемещения, деленное на удвоенное количество ребер.
\end{itemize}

\subsection{Промежуточные переменные}

\begin{itemize}
    \item \texttt{n} - количество узлов в графе.
    \item \texttt{m} - количество ребер в графе, рассчитанное как половина суммы всех элементов матрицы смежности.
    \item \texttt{curr} - текущий узел в процессе блуждания.
    \item \texttt{visited} - булевый вектор, указывающий, были ли посещены узлы.
    \item \texttt{steps} - количество шагов, сделанных в текущем тесте.
    \item \texttt{first_hit} - булева переменная, указывающая, было ли достигнуто первое попадание в конечный узел.
    \item \texttt{visit_count} - количество посещенных узлов.
    \item \texttt{neighbors} - вектор соседних узлов для текущего узла.
    \item \texttt{next} - следующий узел для перехода.
    \item \texttt{cms} - количество шагов для перемещения от начального узла к конечному и обратно в текущем тесте.
    \item \texttt{file_path} - путь к файлу с матрицей смежности.
    \item \texttt{elapsed_time} - время, затраченное на выполнение тестов.
\end{itemize}

\section{Скрипт random walk.m}
В данной работе была разработана программа на языке Octave, которая имитирует случайные блуждания по графу, заданному матрицей смежности. Программа рассчитывает статистические данные. Об этих данных ниже рассказано более подробно. 


@@d random walk @@{
function [fht, ct, mfht, mct, eff_res, ...
mcmt] = random_walk(adj, start, end_, num_sim)
@@< initialization of variables @@>
@@< simulation loop @@>
@@< calculation @@>
@@}
@@o random_walk.m @@{@@< random walk  @@>@@}



В этом блоке инициализируются переменные для количества узлов и ребер в графе, векторов для хранения времени первого попадания, времени полного обхода, и времени перемещения.

@@d initialization of variables @@{
    n = size(adj, 1);
    m = sum(adj(:)) / 2;
    fht = zeros(num_sim, 1);
    ct = zeros(num_sim, 1);
    cmt = zeros(num_sim, 1);
@@}

Этот блок выполняет цикл по числу тестов для выполнения случайных блужданий.

@@d simulation loop @@{
@@< initialising the current state @@>
@@< graph wandering cycle @@>
@@< hit check @@>
@@< update visited nodes @@>
@@< record round-trip time @@>
@@< calculation of travel time @@>
@@}

Этот блок начинает наш основной цикл, инициализируя текущий узел как начальный узел , а также массивы для отслеживания посещенных узлов и количества шагов. Также инициализируются переменные для отслеживания первого попадания в конечный узел и количества посещенных узлов.

@@d initialising the current state @@{
    for sim = 1:num_sim
        curr = start;
        visited = false(n, 1);
        visited(start) = true;
        steps = 0;
        first_hit = false;
        visit_count = 1;
@@}

Этот цикл продолжается до тех пор, пока не будут посещены все узлы графа. Внутри цикла определяется следующий узел для перехода случайным образом из соседей текущего узла.

@@d graph wandering cycle @@{
        while visit_count < n
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            steps = steps + 1;
            curr = next;
@@}

Если это первое попадание в конечный узел, сохраняется количество шагов до первого попадания.

@@d hit check @@{
            if ~first_hit && curr == end_
                fht(sim) = steps;
                first_hit = true;
            end
@@}

Если узел еще не был посещен, он помечается как посещенный, и увеличивается счетчик посещений. После завершения обхода всех узлов записывается количество шагов.

@@d update visited nodes @@{
            if ~visited(curr)
                visited(curr) = true;
                visit_count = visit_count + 1;
            end
        end

	ct(sim) = steps;
@@}

Затем рассчитывается время перемещения от начального узла к конечному и обратно. Это выполняется двумя циклами: один до конечного узла, и один обратно к начальному узлу.

@@d calculation of travel time @@{
        cms = 0;
        curr = start;
        while curr ~= end_
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            cms = cms + 1;
            curr = next;
        end
        while curr ~= start
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            cms = cms + 1;
            curr = next;
        end
        cmt(sim) = cms;
    end
@@}

Здесь рассчитывается среднее время первого попадания, среднее время обхода, среднее время перемещения и сопротивление.

@@d calculation @@{
    mfht = mean(fht);
    mct = mean(ct);
    mcmt = mean(cmt);

    eff_res = mcmt / (2 * m);
end
@@}

\section{Скрипт run random walk.m}
Для запуска функции random walk и получения результатов был разработан скрипт run random walk. Этот скрипт задаёт параметры графа, запускает функцию random walk и выводит результаты на экран.

@@d run random walk @@{
@@< parameters set-up @@>
@@< running simulation@@>
@@< main results output @@>
@@}
@@o run_random_walk.m @@{@@< run random walk @@>@@}

Указание пути к файлу с матрицей смежности, начального узла, конечного узла и числа тестов. Затем чтение матрицы смежности из указанного файла с помощью функции \texttt{dlmread} и сохранение в переменную матрицы смежности.

@@d parameters set-up @@{
args = argv();
if numel(args) < 3
        error('Необходимо указать имя файла с матрицей смежности и',
                'номера двух узлов.');
end

file_path = args{1};
start = str2double(args{2});
end_ = str2double(args{3});
num_sim = 1000;

adj = dlmread(file_path);
@@}

Выполнение функции случайного блуждания с заданными параметрами и измерение затраченного времени с помощью \texttt{tic} и \texttt{toc}. Результаты сохраняются в соответствующих переменных, а время выполнения - в переменной \texttt{elapsed_time}.

@@d running simulation @@{
tic;
[fht, ct, mfht, mct, eff_res, mcmt] = random_walk(adj, start, end_, num_sim);
elapsed_time = toc;
@@}


Этот блок кода выводит основные результаты вычислений, такие как: среднее время первого попадания, среднее время прохода, среднее время обхода всего графа, сопротивление, время выполнения программы

@@d main results output  @@{
fprintf('Среднее время первого попадания в вершину %d из' ,
	'вершины %d: %f шага.\n', end_, start, mfht);
fprintf('Среднее время прохода из вершины %d в вершину %d и' , 
	'обратно: %f шага.\n', start, end_, mcmt);
fprintf('Среднее время обхода всего графа: %f шага.\n', mct);
fprintf('Сопротивление: %f.\n', eff_res);
fprintf('Время выполнения программы: %f секунд.\n', elapsed_time);
@@}

\chapter{Результаты и их анализ}
\section{Проведение тестов}

В качестве примеров мы рассмотрим три графа. Первый граф будет тестовым для понимания методологии решения, вторым графом является Московское метро, третий -- линейный граф.

\subsection{Пример 1}
\[
\text{adj_matrix} = \begin{pmatrix}
0 & 1 & 1 & 0 \\ 
1 & 0 & 1 & 1 \\ 
1 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 
\end{pmatrix}
\]

Начальная вершина была выбрана как вершина 1, а конечная вершина как вершина 4. Количество тестов было установлено на 1000. Результаты тестов показали следующее:

\begin{itemize}
    \item Среднее время первого попадания в вершину 4 из вершины 1: 5.047200 шага.
    \item Среднее время прохода из вершины 1 в вершину 4 и обратно: 10.004400 шага.
    \item Среднее время обхода всего графа: 5.934400 шага.
    \item Сопротивление: 1.000440.
    \item Время выполнения программы: 7.940940 секунд.
\end{itemize}
Стоит заметить, что при стократном увеличении тестов, результаты изменятся незначительно.

\subsection{Пример 2}
В качестве второго примера была взята матрица Московского метро (442 вершины, 630 ребер), так как она позволяет проверить случайное блуждание в реальной транспортной сети. Начальная вершина была выбрана как вершина 1(станция Новокосино), а конечная вершина как вершина 442(станция Апрелевка). Количество тестов было установлено на 100000. Результаты тестов показали следующее:
\begin{itemize}
    \item Среднее время первого попадания в вершину 442 из вершины 1: 17159.75 шага.
    \item Среднее время прохода из вершины 1 в вершину 442 и обратно: 20142.68 шага.
    \item Среднее время обхода всего графа: 40777.67 шага.
    \item Сопротивление: 15.99.
    \item Время выполнения программы: 3194.03 секунд.
\end{itemize}

Резистивное расстояние по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 16.
Тогда из формулы (\ref{C_xy}) следует, что среднее время коммутирования равно:
$$C^t_{(1,442)} = 2mR_{1,442} = 2 * 630 * 16 = 20160$$
Среднее время коммутирования по результатам случайных блужданий:
$$C^r_{(1,442)} \approx 20142$$
Результаты вычислений показывают, что среднее время прохождения из вершины 1 в вершину 442 и обратно почти точно удовлетворяет соотношению формулы (\ref{C_xy}).
$$C^t_{(1,442)} \approx C^r_{(1,442)}$$
Ошибка составлятет 0,01\%.


\subsection{Пример 3}
Третьим примером стал линейный граф с количеством вершин 442 и количеством ребер 441. Количество тестов было установлено на 10000.
\begin{itemize}
    \item Среднее время первого попадания в вершину 442 из вершины 1: 191980.58 шага.
    \item Среднее время прохода из вершины 1 в вершину 442 и обратно: 389058.45 шага.
    \item Среднее время обхода всего графа: 191980.58.
    \item Сопротивление: 441.11.
    \item Время выполнения программы: 32729.89 секунд.
\end{itemize}
Резистивное расстояние по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 441.
Тогда из формулы (\ref{C_xy}) следует, что среднее время коммутирования равно:
$$C^t_{(1,442)} = 2mR_{1,442} = 2 * 441 * 441 = 388962$$
Среднее время коммутирования по результатам случайных блужданий:
$$C^r_{(1,442)} \approx 389058.45$$
Результаты вычислений показывают, что среднее время прохождения из вершины 1 в вершину 442 и обратно достаточно точно удовлетворяет соотношению формулы (\ref{C_xy}).
$$C^t_{(1,442)} \approx C^r_{(1,442)}$$
Ошибка составлятет 0,03\%.



\section{Теоретические расчеты}
\subsection{Пример 1}
Теперь с помощью теории рассчитаем количество шагов до попадания в вершину 4 из вершины 1. Составим матрицу степеней из матрицы смежности, используемой выше:
\[
\text{D} = \begin{pmatrix}
2 & 0 & 0 & 0 \\ 
0 & 3 & 0 & 0 \\ 
0 & 0 & 3 & 0 \\
0 & 0 & 0 & 2 
\end{pmatrix}
\]

Из этих двух матриц составим матрицу Лапласа (Лапласиан), используя данную формулу: {L = D - adj_matrix}
\[
\begin{pmatrix}
2 & 0 & 0 & 0 \\ 
0 & 3 & 0 & 0 \\ 
0 & 0 & 3 & 0 \\
0 & 0 & 0 & 2 
\end{pmatrix}
-
\begin{pmatrix}
0 & 1 & 1 & 0 \\ 
1 & 0 & 1 & 1 \\ 
1 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 
\end{pmatrix}
=
 \begin{pmatrix} 
2 & -1 & -1 & 0 \\ 
-1 & 3 & -1 & -1 \\ 
-1 & -1 & 3 & -1 \\
0 & -1 & -1 & 2 
\end{pmatrix} = \text{L}
\]

Далее мы получаем собственные значения и собственные вектора матрицы Лапласа, чтобы их получить я воспользуюсь Octave:

@@d laplacian @@{
laplacian_matrix = [2 -1 -1 0;                
                   -1 3 -1 -1;
                   -1 -1 3 -1;
                    0 -1 -1 2];


[eigenvectors, eigenvalues_matrix] = eig(laplacian_matrix);

eigenvalues = diag(eigenvalues_matrix);

disp('Собственные значения:');
disp(eigenvalues);

disp('Собственные вектора:');
disp(eigenvectors);
@@}
@@o laplacian.m @@{@@< laplacian @@>@@}


Где eigenvalues – это \(\lambda_k\), а eigenvectors –  это  \(u_{i}\)

$$\lambda_1 = 0, \quad \lambda_2 = 2, \quad \lambda_3 = 4, \quad \lambda_4 = 4$$

\[
\text{U} =  \begin{pmatrix} 
-0.50 & -0.71 & 0.49 & 0.09 \\
-0.50 & 0.00 & -0.62 & 0.60 \\
-0.50 & 0.00 & -0.36 & -0.79 \\
-0.50 & 0.71 & 0.49 & 0.09 \\
\end{pmatrix} 
\]



У собственных значений убираем нулевое значения и берем нулевую и третью строки из матрицы \(U\) для расчета \(R_{14}\). Получаем следующее:
$$ \lambda_2 = 2, \quad \lambda_3 = 4, \quad \lambda_4 = 4 $$
$$ u_0  = (-0.50, -0.71, 0.49, 0.09)$$
$$ u_3  = (-0.50, 0.71, 0.49, 0.09)$$

Теперь нам нужны значения \(n\) и \(m\). У нас \(n\) уже известна, она равна 4, поэтому осталось найти \(m\). Для этого находим сумму всех элементов матрицы смежности и делим их на 2.

$$ \sum_{i,j} A_{ij} = 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 = 10$$

$$ E = \frac{10}{2} = 5$$

В итоге получаем, что \(m\) = 5 и \(n\) = 4. Получив эти значения, мы можем посчитать сопротивление
$$ R_{14} = \sum_{k=1}^{n-1} \frac{(u_{k1} - u_{k4})^2}{\lambda_k} = \frac{(0.71 - (-0.71))^2}{2} + $$
$$ + \frac{(0.49 - 0.49)^2}{4} + \frac{(0.09 - 0.09)^2}{4} \approx 1.0082$$

Теперь нужно посчитать commute time, для этого воспользуемся формулой (\ref{C_xy_end}):

$$ C_{14} = 2mR_{14} = 2 * 5 * 1.0083 \approx 10.0082$$

Нам осталось посчитать только hitting time, но так как наш граф является маленьким и симметричным, то у нас есть возможность воспользоваться данным вариантом формулы (\ref{C_xy_end}):
$$ C_{14} = H_{14} + H_{41} $$
Для нашего маленького и симметричного графа, это равносильно что:
$$ C_{14} \approx 2H_{14} $$
Следовательно \(H_{14}\) равен:
$$ H_{14}  \approx \frac{C_{14} }{2} \approx \frac{10.0082}{2} \approx 5.0041$$ 

\subsection{Пример 2}
Пример 1 был приведен для демонстрации методологии. Поскольку нахождение вручную данных графа Московского метро практически невозможно, воспользуемся программным методом. Для этого была написана программа, которая воспроизводит вычисления формул: $R_{xy}$, $H_{xy}$, $C_{xy}$.

@@d theoretical random walk @@{
@@< parameters @@>
@@< calculation of eigenvalues and eigenvectors @@>
@@< parameters of the iterative process @@>
@@< neighbourhood lists @@>
@@< calculate the matrix H @@>
@@< calculation of results  @@>
@@< result output @@>
@@}
@@o theoretical_random_walk.m @@{@@< theoretical random walk @@>@@}


В этой части кода, мы загружаем матрицу смежности графа из файла. Затем определяем количество вершин и ребер.
@@d parameters @@{
args = argv();
if numel(args) < 3
        error('Необходимо указать имя файла с матрицей смежности и', 
                'номера двух узлов.');
end
file_path = args{1};
adj_matrix = dlmread(file_path);

n = size(adj_matrix, 1);
m = sum(adj_matrix(:)) / 2;
@@}


Здесь мы вычисляем по формулам собственные значения и собственные векторы. Далее извлекаем собственные значения в вектор. И отбрасываем первое нулевое собственное значение и соответствующий ему собственный вектор (они не нужны для дальнейших вычислений).

@@d calculation of eigenvalues and eigenvectors @@{
degree_matrix = sum(adj_matrix, 2);

laplacian_matrix = diag(degree_matrix) - adj_matrix;

[eigenvectors, eigenvalues_matrix] = eig(laplacian_matrix);
eigenvalues = diag(eigenvalues_matrix);

eigenvalues_nonzero = eigenvalues(2:end);
eigenvectors_nonzero = eigenvectors(:, 2:end);

@@}

В этой части код инициализируем матрицу H нулями. Задаем максимальное количество итераций и допустимую ошибку.
@@d parameters of the iterative process @@{
H = zeros(n, n);

max_iter = 200000;
tol = 1e-16;
@@}


Здесь начинаем подсчет времени выполнения. Затем создаем список соседей для каждой вершины. В каждом элементе этого массива neighbors будут храниться массивы индексов соседей соответствующей вершины.

@@d neighbourhood lists @@{
tic;

neighbors = cell(n, 1);
for i = 1:n
    neighbors{i} = find(adj_matrix(i, :) == 1);
end
@@}


В этом блоке в каждой итерации обновляем значения H для всех вершин, используя их соседей. Затем каждые 10000 итераций выводим текущую ошибку. Если ошибка становится меньше заданного порога (tol), процесс останавливается. И в конце записываем время выполнения итерационного процесса.
@@d calculate the matrix H @@{
for iteration = 1:max_iter
    H_prev = H;
    for u = 1:n
        if degree_matrix(u) > 0
            H(u, :) = 1 + (1 / degree_matrix(u)) * sum(H(neighbors{u}, :), 1);
        end
        H(u, u) = 0;  % Условие H_ii = 0
    end
    if mod(iteration, 10000) == 0
        disp(['Итерация: ', num2str(iteration), ' H - ', num2str(max(max(abs(H - H_prev))))]);
    end
    if max(max(abs(H - H_prev))) < tol
        disp(['Сошлось после ', num2str(iteration), ' итераций']);
        break;
    end
end
elapsed_time = toc;
@@}


Здесь мы рассчитаем среднее время прохождения, время возвращения и сопротивление между заданными вершинами на основе полученных данных.
@@d calculation of results @@{
i = str2double(args{2});
j = str2double(args{3});

H_ij = H(i, j);

R_ij = sum((eigenvectors_nonzero(i, :) - eigenvectors_nonzero(j, :)).^2 ./ eigenvalues_nonzero');

C_ij = 2 * m * R_ij;
@@}

Выводим вычисленные результаты.
@@d result output @@{
disp(['Среднее время прохода из вершины ', num2str(i), ' в вершину ', num2str(j), ': ', num2str(H_ij)]);
disp(['Среднее время прохода из вершины ', num2str(i), ' в вершину ', num2str(j), ' и обратно: ', num2str(C_ij)]);
disp(['Сопротивление: ', num2str(R_ij)]);
disp(['Время выполнения программы: ', num2str(elapsed_time), ' секунд']);
@@}

 
 Результаты данных вычислений:
 \begin{itemize}
    \item Сошлось после 293492 итераций
    \item Среднее время прохождения из вершин 1 в вершину 442: 17085.752085552034
    \item Среднее время прохождения из вершины 1 в вершину 442 и обратно: 20199.377213668093
    \item Сопротивление: 16.03125175687944
    \item Время выполнения программы: 2841.8106 секунд
\end{itemize}

\subsection{Пример 3}
Результаты вычислений для линейного графа:
 \begin{itemize}
    \item Сошлось после 2016601 итераций
    \item Среднее время прохождения из вершин 1 в вершину 442: 194480.99999830942
    \item Среднее время прохождения из вершины 1 в вершину 442 и обратно: 388961.9999977657
    \item Сопротивление: 440.9999999974668
    \item Время выполнения программы: 8452.6199 секунд
\end{itemize}

Результаты вычислительных экспериментов и теоретических расчетов для графа демонстрируют 
высокую степень согласованности, что свидетельствует о правильности применяемых моделей и алгоритмов. 
Тестирование проводилось на графе с четырьмя вершинами, на котором было установлено, что теоретические предсказания совпадают с практическими результатами. 
Кроме того, применение данных методов на лиенйном графе и на графе Московского метро показало, 
что алгоритмы могут работать не только в теоретических условиях, но и с реальной 
транспортной сетью. 
Среднее время первого попадания, прохождения и обхода всего графа, 
а также сопротивление, полученные в результате тестов, находятся в хорошем 
согласии с теоретическими расчетами. 
Эти три случая подтверждают, что предложенные модели и алгоритмы могут быть успешно 
применены для анализа и прогнозирования поведения более сложных и масштабных транспортных 
сетей.

\backmatter
\chapter{Заключение}

В рамках данной исследовательской работы была рассмотрена задача нахождения резистивного расстояния между узлами электрической цепи, представленной в виде графа. 
В результате проведенных теоретических исследований и разработок удалось достичь следующих результатов:

\begin{enumerate}
    \item \textbf{Математическое моделирование электрических цепей}:
    \begin{itemize}
        \item Электрические цепи были успешно смоделированы с помощью теории графов, где узлы сети представляли вершины графа, а сопротивления между узлами --- веса ребер.
        \item Была установлена взаимосвязь между Законами Кирхгофа и резистивным расстоянием, что позволяет использовать математические методы теории графов для анализа электрических цепей.
    \end{itemize}

    \item \textbf{Вывод резистивного расстояния}:
    \begin{itemize}
        \item Резистивное расстояние между двумя вершинами графа было определено как сопротивление между соответствующими узлами в электрической цепи, где все сопротивления заменены на единичные.
        \item Была выведена формула для нахождения резистивного расстояния с использованием обобщенной обратной матрицы Лапласиана графа, что позволило упростить вычисления и сделать их более наглядными.
    \end{itemize}

        \item \textbf{Разработка программ}:
    \begin{itemize}
        \item На языке Octave были разработаны алгоритмы для вычисления резистивного расстояния между двумя вершинами графа, а также алгоритм случайного блуждания. Программы обеспечивают универсальность использования, позволяют загружать матрицу смежности из файла и вычислять ффективное сопротивление и метрики случайных блужданий.
        \item Программа была протестирована, результаты тестирования показали ее корректность.
    \end{itemize}

    \item \textbf{Практическое применение}:
    \begin{itemize}
        \item Разработанные модели и программа могут быть использованы для анализа и оптимизации различных сетей, включая электрические, транспортные и коммуникационные сети.
        \item Методика может быть полезна в таких областях, как проектирование электрических цепей, анализ надёжности сетей и оптимизация маршрутов.
    \end{itemize}
\end{enumerate}

Таким образом, проделанная работа позволяет сделать вывод о том, что применение теории графов и 
метода случайных блужданий для анализа электрических цепей является перспективным направлением исследований.

 Разработанные алгоритмы и программы могут быть полезны в практике инженеров и исследователей, 
занимающихся анализом и оптимизацией сложных сетей.


\bibliographystyle{gost780u}
\bibliography{rpz}
\end{document}

@


1.26
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.25 $
\RCS $Date: 2024/07/14 10:53:04 $
a37 1
\begin{document}
d39 1
d42 2
a43 1
	РОССИЙСКОЙ ФЕДЕРАЦИИ Федеральное государственное автономное\\
d45 1
a45 1
	Дальневосточный федеральный университет» \\
d50 1
a50 1
\NirBoss{}{} %% Заказчик, утверждающий НИР
a51 1
\NirManager{Профессор, д.ф-м.н.}{Е.А.Нурминский} %% Название организации
d59 3
a61 3
\NirUdk{УДК \No 2123132123}
\NirGosNo{Регистрационный \No 123123}

d63 14
a76 1
\NirTitle{\textbf{"Случайные блуждания: связь с резистивным расстоянием"}} %%% Название НИР и генерация титульного листа
d78 2
a79 12
Revision: \RCSRevision, 
Date: \RCSDate, 
Author: \RCSAuthor  
\Executors{
\begin{itemize}
	\item Вершинин Д. А. \hfill \underline{\hspace{3cm}}
	\item Пелагеев Д. И. \hfill \underline{\hspace{3cm}}
	

  %[\item Вершинин Данил Алексеевич
  % Добавьте других исполнителей здесь
\end{itemize}}
@


1.25
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.24 $
\RCS $Date: 2024/07/14 09:51:03 $
d737 1
a737 1
Если узел еще не был посещен, он помечается как посещенный, и увеличивается счетчик посещений.
a744 3
@@}

После завершения обхода всех узлов записывается количество шагов.
d746 1
a746 2
@@d record round-trip time @@{
        ct(sim) = steps;
@


1.24
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.23 $
\RCS $Date: 2024/07/14 09:43:31 $
d49 1
a49 1
\NirBoss{Директор ООО "Рога и Копыта"}{И.И.Иванов} %% Заказчик, утверждающий НИР
d158 1
a158 1
вершины происходит случайно с равной вероятностью для всех соседей текущей вершины.
d210 1
a210 1
Такой базисный вектор определяется как $\mathbf{e}, \mathbf{e}\in V(G)$. 
d222 1
a222 1
Элементы матрицы инцидентности $A$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $A$ и вектора $\mathbf{y}$
d250 1
a250 1
		\mathbf{\phi} \equiv \sum_x \mathbf{x},
d270 1
a270 1
	где $\mathbf{a, b, x ,y}$ - вектора, в которых элементы с номерами $a,b,x,y$ (соответственно) равны 1, а остальные элементы --  0;
d566 1
d604 1
a604 1
	\item Большие графы: для графа с 1000 вершинами и заполненностью 90\% расчет занимает 6.5 секунд. Граф с 3000 вершинами и заполненностью 25\% рассчитывается за 500 секунд. Больше данных изображено на Рис. 4.1
a646 3
    \item \texttt{sfh} - отсортированный вектор времени первого попадания и их количества.
    \item \texttt{sct} - отсортированный вектор времени полного обхода графа и их количества.
    \item \texttt{scmt} - отсортированный вектор времени перемещения и их количества.
d836 1
a836 1
В качестве примеров мы рассмотрим два графа. Первый граф будет тестовым для понимания методологии решения, а вторым графом является Московское метро.
d888 1
a888 1
Резистивное расстояние результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 441.
@


1.23
log
@effects.
@
text
@d4 2
a5 2
\RCS $Revision: 1.22 $
\RCS $Date: 2024/07/14 07:52:08 $
d831 1
a831 1
fprintf('Эффективное сопротивление: %f.\n', eff_res);
d856 1
a856 1
    \item Эффективное сопротивление: 1.000440.
d867 1
a867 1
    \item Эффективное сопротивление: 15.99.
d871 1
a871 1
Эффективное сопротивление по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 16.
d887 1
a887 1
    \item Эффективное сопротивление: 441.11.
d890 1
a890 1
Эффективное сопротивление по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 441.
@


1.22
log
@add some explans
@
text
@d4 2
a5 2
\RCS $Revision: 1.21 $
\RCS $Date: 2024/07/14 07:31:29 $
d44 1
a44 1
	«Дальневосточный федеральный университет» \\
d318 1
a318 1
		Формально определим эффективное сопротивления как расстояние.
d448 1
a448 1
	умноженному на эффективное сопротивление \(R_{xy}\)\cite{3}.
d473 1
a473 1
\chapter{Программа для расчета эффективного сопротивления с помощью законов Кирхгофа}
d566 1
a566 1
Создается результирующий вектор h и производится расчет резистивного расстояния (эффективного сопротивления).
d652 1
a652 1
    \item \texttt{eff_res} - эффективное сопротивление графа, рассчитанное как среднее время перемещения, деленное на удвоенное количество ребер.
d776 1
a776 1
Здесь рассчитывается среднее время первого попадания, среднее время обхода, среднее время перемещения и эффективное сопротивление.
d823 1
a823 1
Этот блок кода выводит основные результаты вычислений, такие как: среднее время первого попадания, среднее время прохода, среднее время обхода всего графа, эффективное сопротивление, время выполнения программы
d985 1
a985 1
В итоге получаем, что \(m\) = 5 и \(n\) = 4. Получив эти значения, мы можем посчитать эффективное сопротивление, воспользуемся формулой (4.2):
d1088 1
a1088 1
Здесь мы рассчитаем среднее время прохождения, время возвращения и эффективное сопротивление между заданными вершинами на основе полученных данных.
d1104 1
a1104 1
disp(['Эффективное сопротивление: ', num2str(R_ij)]);
d1114 1
a1114 1
    \item Эффективное сопротивление: 16.03125175687944
d1124 1
a1124 1
    \item Эффективное сопротивление: 440.9999999974668
d1135 1
a1135 1
а также эффективное сопротивление, полученные в результате тестов, находятся в хорошем 
d1156 1
a1156 1
        \item Резистивное расстояние между двумя вершинами графа было определено как эффективное сопротивление между соответствующими узлами в электрической цепи, где все сопротивления заменены на единичные.
d1162 1
a1162 1
        \item На языке Octave были разработаны алгоритмы для вычисления резистивного расстояния между двумя вершинами графа, а также алгоритм случайного блуждания. Программы обеспечивают универсальность использования, позволяют загружать матрицу смежности из файла и вычислять эффективное сопротивление и метрики случайных блужданий.
d1174 1
a1174 1
метода случайных блужданий для анализа электрических цепей является эффективным и перспективным направлением исследований.
@


1.21
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.20 $
\RCS $Date: 2024/07/14 07:29:43 $
d283 1
a283 1
	где $\mathbf{a, b, x ,y}$ - вектора, в которых элементы с номерами $a,b,x,y$ (соответственно) равны 1, а остальные 0.
d305 1
a305 1
Разность потенциалов между двумя точками, как видно из (\ref{tok6}), прямо пропорциональна $I$. 
d310 1
a310 1
	Для физического тока из $a$ в $b$ в графе $G$ резистивное расстояние равно
@


1.20
log
@transpose
@
text
@d4 2
a5 2
\RCS $Revision: 1.19 $
\RCS $Date: 2024/07/14 06:46:27 $
d268 1
a268 1
		i_{xy} = \frac{I}{r_{xy}} ((\mathbf{x -y} )(\Delta - A)^+( \mathbf{ a-b})),
@


1.19
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.18 $
\RCS $Date: 2024/07/14 06:41:49 $
d281 1
a281 1
	\mathbf{x} \Delta \mathbf{x} v_x - \sum_y \mathbf{x} A \mathbf{y} v_y = I (\mathbf{x} \cdot (\mathbf{ a -b})),
d297 1
a297 1
	v_x - v_y = I((\mathbf{x - y})(\Delta - A)^+ (\mathbf{a-b}))
d301 1
a301 1
        v_x - v_y = i_{xy} r_{xy} \Rightarrow i_{xy} = \frac{v_x - v_y}{r_{xy}} = \frac{I}{r_{xy}} ((\mathbf{x - y})(\Delta - A)^+ (\mathbf{a-b}))
d312 1
a312 1
		\Omega_{ab} = (\mathbf{a-b})(\Delta - A)^+(\mathbf{a-b})
@


1.18
log
@done!
@
text
@d4 2
a5 2
\RCS $Revision: 1.17 $
\RCS $Date: 2024/07/14 04:43:24 $
d114 1
d221 1
a221 1
\end{equation}
@


1.17
log
@update random walk
@
text
@d4 2
a5 2
\RCS $Revision: 1.16 $
\RCS $Date: 2024/07/14 04:24:25 $
d97 1
a97 1
	\item[Лапласиан] Квадратная матрица, вычисляемая на основе матрицы смежности графа, которая используется для анализа свойств графов и их спектров.
a113 3
		    \item \textbf{Сопротивление проводника:} Сопротивление \(R\) проводника также можно вычислить по формуле: \(R = \rho \frac{L}{A}\), где \(\rho\) — удельное сопротивление материала, \(L\) — длина проводника, \(A\) — площадь его поперечного сечения.
		\end{itemize}

d191 1
a191 24
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
% Nodes
		\node[draw, circle] (a) at (0,0) {$a$};
		\node[draw, circle] (x) at (0,2) {$x$};
		\node[draw, circle] (y) at (6,2) {$y$};
		\node[draw, circle] (b) at (6,0) {$b$};
				    
% Edges with currents
		\draw[->] (a) -- node[midway, left] {$i_{ax} = -i_{xa}$} (x);
		\draw[->] (x) -- node[midway, above] {$i_{xy} = -i_{yx}$} (y);
		\draw[->] (y) -- node[midway, right] {$i_{yb}$} (b);
		\draw[->] (a) -- node[midway, below] {$i_{ab}$} (b);
		\draw[->] (x) --  (a);
		\draw[->] (y) --  (x);

% Potentials
										        
% Resistances
	\end{tikzpicture}
	\caption{Иллюстрация формул (\ref{tok1}) и (\ref{tok2})}
	\label{fig:graph}
\end{figure}
d193 1
a193 1
	Ток называют физическим \cite{RD2}, если существует потенциал $v$ на вершинах графа $G$ такая, что:
d199 1
d221 3
a223 1
Элементы матрицы инцидентности $A$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $A$ и вектора $\mathbf{y}$, где $\mathbf{x}$ - вектор, 
d237 3
a239 2
Элементы матрицы степеней $\Delta$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $\Delta$ и вектора $\mathbf{y}$, где $\mathbf{x}$ - вектор,
в котором элемент с номером $x$ равен 1, а остальные 0;
d241 2
a242 1
$\Delta$ - матрица степеней графа $G$
d265 1
a265 1
	Физический ток в графе $G$ из вершины $a$ в вершину $b$ в связном графе существует, является единственным и определяется следующим образом:
d269 1
a269 1
	где $\mathbf{a, b, x ,y}$ - вектора, в которых элементы с номерами $a,b,x,y$ (соответственно) равны 1, а остальные 0;
d283 2
a284 1
	Теперь $\forall x \in V(G)$ и т.к. $x$ и $y$ сопостовимы, перепишем это как:
d305 1
a305 1
При выборе $x=a$ и $y=b$, этот коэффициент пропорциональности называется эффективным сопротивлением $\Omega_{ab}$ между $a$ и $b$. 
d309 1
a309 1
	Для физического тока из $a$ в $b$ в графе $G$:
d342 1
a342 1
	Подадим на каждый узел сети ток, равное количеству связей этого узла ($d(x)$). 
d407 1
a407 1
	Установим условия для $x=y$
d427 2
a428 2
	Сценарий B является схожим со сценарием A, за исключением того, что весь ток входит в вершину $x$. 
	Обозначим разность потенциалов сценария B за $\phi_{yx}'$.
d431 1
a431 1
	$$\phi_{y,x}' = H_{yx} $$
d435 2
a436 2
	Ток будем входить во все узлы сети.
	Обозначим разность потенциалов сценария C за $\phi_{xy}''$.
d438 1
a438 1
	Данный сценарий является обратным к сценарию B, т.к. изменение затронуло только направление тока в сети.
@


1.16
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.15 $
\RCS $Date: 2024/07/14 04:09:26 $
d362 1
a362 1
	Подадим на каждый узел сети напряжение, равное количеству связей этого узла ($d(x)$). 
d364 1
a364 1
	Выбор количества тока обусловлен тем фактом, что сумма количества связей каждой вершины даст число, равное удвоенному количеству связей в цепи.
a366 2
Также введём следующие определения.

d368 1
a368 1
	Для любых двух вершин $x$ и $y$  графа $G$ время попадания (hitting time) определяется, 
d375 2
a376 3
	Время возвращения (commute time) $C_{xy}$ между двумя вершинами $x$ и $y$ в графе $G$ является мато жидание или же 
	среднее количество шагов (steps) случайного блуждания, 
	необходимое для прохождения пути из вершины $x$ в вершину $y$ и обратно.
d447 1
a447 1
	Сценарий B является схожим со сценарием A, за исключением того, что ток снимается с вершины $x$. 
d454 2
a455 2
	Подадим напряжение, равное $2m$ на узел $x$, где $m$ - количество связей цепи.
	Ток будем снимать со всех узлов сети.
d477 1
a477 1
	Другими словами, подадим ток $2m$ на вершину $x$ и снимем его с вершины $y$.
@


1.15
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.14 $
\RCS $Date: 2024/07/14 04:05:34 $
d301 1
a301 1
	\mathbf{x} \Delta \mathbf{x} v_x - \sum_y \mathbf{x} A \mathbf{y} v_y = I (\mathbf{x} \cdot (\mathbf{ a -b}))
d303 2
a304 1
	Теперь $\forall x \in V(G)$, перепишем это как:
d314 1
a314 1
	Разность потенциалов между парой вершин $x,y$ дает нам
@


1.14
log
@done?
@
text
@d4 2
a5 2
\RCS $Revision: 1.13 $
\RCS $Date: 2024/07/14 03:38:28 $
d304 1
a305 1
	\Delta \sum_x \mathbf{x} v_x - A \sum_x \mathbf{X} v_x = I (\mathbf{a-b})\\
@


1.13
log
@remove some bracets
@
text
@d4 2
a5 2
\RCS $Revision: 1.12 $
\RCS $Date: 2024/07/14 03:18:40 $
d301 1
a301 1
	\mathbf{x} \Delta \mathbf{x} v_x - \sum_y \mathbf{x} A \mathbf{y} v_y = I \mathbf{x} \cdot \mathbf{ a -b}
d305 2
a306 2
	\Delta \sum_x \mathbf{x} v_x -  
	%(\Delta - A)\sum_x v_x|x\rangle  = I\langle x | a - b\rangle. 
d310 1
a310 1
	\sum_x v_x|x\rangle = I\{Q/(\Delta - A)\} |a-b\rangle + c|\phi\rangle, 
d312 1
a312 1
	где $c$ еще не определенная константа. Это непосредственно приводит к формуле нашей теоремы, тем самым устанавливая уникальность этих различий. 
d315 1
a315 1
	v_x - v_y = I\langle x -y|Q/(\Delta - A) |a-b\rangle
d317 4
a320 1
	Тогда, закон Ома (\ref{tok3}) дает формулу леммы, единственность $I$ и его существование.
d327 1
a327 1
\begin{theorem} [О резистивном сопротивлении]
d330 1
a330 1
		\Omega_{ab} = \langle a-b|Q/(\Delta - A)| a -b\rangle
@


1.12
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.11 $
\RCS $Date: 2024/07/14 03:17:28 $
d235 1
a235 1
Размерность этого простравнства равна количеству вершин в графе $G$
d246 1
a246 1
Элементы матрицы смежности $A$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $A$ и вектора $\mathbf{y}$, где $\mathbf{x}$ - вектор, 
d249 1
a249 1
$A$ - матрица смежности графа $G$
d256 1
a256 1
		\Delta_{xy} = \delta_{xy}\sum_z^{\sim x}1/r_{xz}
d258 1
a258 1
	где суммирование происходит по вершинам $z\in V(G)$, которые смежны с $x$, называется матрицей степеней вершин. 
d279 2
a280 1
	Однако в подпространстве, ортогональном к $\mathbf{\phi}$, он имеет псевдообратную матрицу, которая задаётся $(\Delta - A)^+=((\Delta - A)^T(\Delta - A))^{-1}(\Delta - A)^T$
d288 1
a288 1
		i_{xy} = \frac{I}{r_{xy}} \mathbf{x -y} \cdot (\Delta - A)^+\cdot \mathbf{ a-b},
d301 1
a301 1
	\langle x| \Delta | x \rangle v_x - \sum_y \langle x | A | y \rangle v_y = I\langle x | a -b \rangle
d303 1
a303 1
	Теперь $\forall x \in V(G)$, это можно переписать как:
d305 2
a306 1
	(\Delta - A)\sum_x v_x|x\rangle  = I\langle x | a - b\rangle. 
@


1.11
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.10 $
\RCS $Date: 2024/07/14 03:16:00 $
d248 1
a248 1
\mathbf{y} - вектор,в котором элемент с номером $y$ равен 1, а остальные 0;
@


1.10
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.9 $
\RCS $Date: 2024/07/14 03:14:02 $
d260 1
a260 1
Элементы матрицы степеней $\Delta$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $\Delta$ и вектора \mathbf{y}, где \mathbf{x} - вектор,
d262 1
a262 1
\mathbf{y} - вектор,в котором элемент с номером $y$ равен 1, а остальные 0;
@


1.9
log
@remove some dirack
@
text
@d4 2
a5 2
\RCS $Revision: 1.8 $
\RCS $Date: 2024/07/14 02:35:33 $
d246 1
a246 1
Элементы матрицы смежности $A$ можно также получить через скалярное произведение вектора $\mathbf{x}^T$, матрицы $A$ и вектора \mathbf{y}, где \mathbf{x} - вектор, 
@


1.8
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.7 $
\RCS $Date: 2024/07/14 02:32:53 $
d235 1
d240 1
a240 1
	A_{xy} = \langle x|A|y\rangle = 
d244 1
a244 1
	\end{cases} \ x,y \in V(G) 
d246 4
d256 1
a256 1
		\Delta_{xy} = \langle x|\Delta|y\rangle=\delta_{xy}\sum_z^{\sim x}1/r_{xz}
d260 4
a263 1

d270 1
a270 1
		|\phi\rangle \equiv \sum_x |x\rangle,
d279 1
a279 1
	Однако в подпространстве, ортогональном к $|\phi\rangle$, он действительно имеет обратную матрицу.
a280 5
Матрица, равная на этом подпространстве обратной и в остальных случаях равная нулю, обозначается как $Q/(\Delta - A)$, где 
$Q$ — это (эрмитовый или идемпотентный) проекционный оператор:
\begin{equation}\label{tok8}
	Q = 1 - \frac{1}{\langle\phi | \phi\rangle} |\phi\rangle \langle\phi|
\end{equation}
d282 1
a282 11
\begin{definition}[Обобщенная обратная матрица Лапласиана]
	Результирующая матрица $\{Q/(\Delta - A)\}$, удовлетворяющая условиям
	\begin{equation}
	\{Q/(\Delta - A)\}(\Delta - A) = (\Delta - A)\{Q/(\Delta - A)\} = Q, 
	\end{equation}
	\begin{equation}
		\{Q/(\Delta - A)\}Q = Q\{Q/(\Delta - A)\} = \{Q/(\Delta - A)\} 
	\end{equation}
	называется обобщенной обратной матрицей Лапласиана.
\end{definition}
\section{Эффективное сопротивление}
d287 1
a287 1
		i_{xy} = \frac{I}{r_{xy}}\langle x -y| Q/(\Delta - A)| a-b\rangle,
d289 2
a290 1
	где $|a-b\rangle \equiv |a\rangle - |b\rangle$.		
@


1.7
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.6 $
\RCS $Date: 2024/07/14 02:30:06 $
d234 1
a234 1
Такой базисный вектор определяется как $\mathcal{e}, \mathcal{e} \in V(G)$. 
@


1.6
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.5 $
\RCS $Date: 2024/07/14 01:21:14 $
d234 1
a234 1
Такой базисный вектор определяется как $\mathbb{e}, \mathbb{e} \in V(G)$. 
@


1.5
log
@*** empty log message ***
@
text
@d4 2
a5 2
\RCS $Revision: 1.4 $
\RCS $Date: 2024/07/13 06:31:44 $
d234 1
a234 1
Такой базисный вектор определяется как $|x\rangle, x \in V(G)$. 
@


1.4
log
@update some theory
@
text
@d4 2
a5 2
\RCS $Revision: 1.3 $
\RCS $Date: 2024/07/12 11:38:49 $
d219 1
a219 1
	Ток называют физическим \cite{RD2}, если существует потенциал-функция $v$ на вершинах графа $G$ такая, что:
d223 1
a223 1
	где $r_{xy} \equiv r_{e}$, при $e=\{x,y\}$. 
d225 2
a226 2
Потенциал-функция известна как напряжение (аналог давления в гидравлике), а уравнение (\ref{tok3}) также известно как закон Ома.
Для тока в графе  $G$ существование такой потенциал-функции может быть показано через второй закон Кирхгофа для цепей:
@


1.3
log
@update
@
text
@d4 2
a5 2
\RCS $Revision: 1.2 $
\RCS $Date: 2024/07/12 11:20:21 $
d87 1
a87 1
	\item[Ребро] Соединение между двумя вершинами графа, соответствующее электрическому сопротивлению в электрической цепи.
d89 1
a89 1
	\item[Резистивное расстояние] Эффективное сопротивление между двумя вершинами в графе, моделирующем электрическую цепь, когда все сопротивления заменены на единичные.
d91 3
a93 1
	\item[Законы Кирхгофа] Физические законы, описывающие сохранение электрического заряда и энергии в электрической цепи. Первый закон (Закон узлов) утверждает, что сумма токов, входящих в узел, равна сумме токов, выходящих из узла. Второй закон (Закон контуров) гласит, что сумма напряжений в любом замкнутом контуре цепи равна нулю.
d101 1
a101 1
	\item[Обращение матрицы] Операция, при которой для данной квадратной матрицы \(A\) находится такая матрица \(A^{-1}\), что произведение \(A \cdot A^{-1}\) равно единичной матрице. Обратная матрица существует только для невырожденных (не сингулярных) матриц.
d158 1
a158 1
Существует также тесная связь с методом случайных блужданий.
d161 1
a161 1
Случайное блуждание моделирует поведение тока в идеальных электрических цепях.
a175 4
Например, уравнение Шокли моделирует силу тока в полупроводниковых диодах \cite{shkl}:
$$I = I_S\left(e^{{U}/{nV_T}} - 1\right),$$
где $I$ -- искомый ток, $I_S$ -- обратный ток насыщения, $U$ -- напряжение, $n$ -- коэффициент качества, $V_T$ -- тепловое напряжение.

d179 1
a179 1
	Ток от вершины $x$ до $y$ графа $G$ определяется как функция $i$ на парах смежных вершин такая, что:
d189 1
a189 1
Эта формула описывает сумму токов, входящих в вершину $x$. 
d192 1
a192 1
Таким образом, $I$ представляет собой величину чистого тока, входящего из источника $a$ и выходящего в сток $b$.
a211 4
		\node at (0,-0.6) {$v_a$};
		\node at (0,2.6) {$v_x$}; 
		\node at (6,2.6) {$v_y$};
		\node at (6,-0.6) {$v_b$};
a213 3
		\node at (1,1) {$r_{ax}$};
		\node at (3,1.5) {$r_{xy}$};
		\node at (5,1) {$r_{yb}$};
@


1.2
log
@pre old.
@
text
@a0 1
%\documentclass[13t]{article}
d4 2
a5 2
\RCS $Revision: 1.1 $
\RCS $Date: 2024/07/12 11:19:44 $
a6 1
%\usepackage[utf8]{inputenc} % Кодировка ввода
a14 3
%\usepackage{titlesec} % Для настройки заголовков разделов
%\usepackage{titling} % Для настройки титульной страницы
%\usepackage{geometry} % Для настройки размеров страницы
a16 1
%\pgfplotsset{compat=1.9}
a18 15
% Настройка заголовков разделов
%\titleformat{\section}
%{\normalfont\Large\bfseries}{\arabic{section}}{1em}{}
%\titleformat{\subsection}
%{\normalfont\large\bfseries}{}{1em}{}

% Настройка титульной страницы
%\setlength{\droptitle}{-3em} % Отступ заголовка
%\title{\vspace{-1cm}Резистивное расстояние}
%\author{Вершинин Данил Алексеевич}
%\date{\today}

% Настройка размеров страницы
%\geometry{a4paper, margin=2cm}
%\geometry{left=30mm, top=20mm, right=15mm, bottom=20mm}
a33 1
% Настройка размеров страницы
a39 2
% Определяем заголовки для титульной страницы
%\NirOrgLongName{\textsc{Дальневосточный Федеральный Университет}} %% Полное название организации
d117 1
a117 1
	\item[Сила тока] Количество электрического заряда, проходящего через поперечное сечение проводника за единицу времени, измеряемая в амперах (А). Определяется как \(I = \frac{Q}{t}\), где \(Q\) — заряд в кулонах, \(t\) — время в секундах.
a118 1
	%\item[Octave] Программная среда для выполнения математических вычислений, аналогичная MATLAB, используемая для разработки и тестирования алгоритмов.
a265 1
Она крайне удобна для следующей леммы:
d372 2
a373 2
	Из узла $y$ получим ток, равный $2m = \sum_x d(x)$, где $m$ - количетсво связей в сети.  
	Выбор количества тока обусловлен тем фактом, чтобы ток равномерно распределится по цепи.
d380 1
a380 1
	как матожидание или же среднее количество шагов (steps) случайного блуждания, 
d386 1
a386 1
	Время возвращения (commute time) $C_{xy}$ между двумя вершинами $x$ и $y$ в графе $G$ является матожидание или же 
d403 1
d411 1
a411 1
	Следовательно суммирование $\phi_{xy}$ будет производиться столько раз, какую степень имеет вершина $x$. Тогда,(\ref{d_x_1}) можно переписать:
d417 1
a417 1
	Решая уравнение, отностильено $\phi_{xy}$, получим следующее:
d421 1
a421 1
	Введем дополнительное условие для случая, $x=y$:
d448 1
a448 1
	Следовательно получим.
d470 1
a470 1
	Данный сценарий является обратным к сценарию B, т.к. измененеи затронуло только направление тока в сети.
d489 1
a489 1
	Другими словами, подадим ток $2m$ на вершину $x$ и снимим его с вершины $y$.
d498 1
a498 1
	\begin{equation}
d504 2
a505 2
\chapter{Разработка программы для рассчета эффективного сопротивления}
Для выполнения разработки программы был выбран язык программирования Octave\cite{octv1},
d517 1
a517 1
На основании этих задач был разработан скрипт {\tt mainKirg} на языке Octave, приведенный ниже.
d563 1
d703 1
a703 1
\section{Скрипт random_walk.m}
d707 3
a709 3
@@d random_walk @@{
function [fht, ct, sfh, sct, mfht, mct, eff_res, ...
mcmt, scmt] = random_walk(adj, start, end_, num_sim)
a712 1
@@< sort function @@>
d714 1
a714 1
@@o random_walk.oc @@{@@< random_walk  @@>@@}
d739 1
a739 1
Этот блок начинает наш основной цикл, инициализируюя текущий узел как начальный узел , а также массивы для отслеживания посещенных узлов и количества шагов. Также инициализируются переменные для отслеживания первого попадания в конечный узел и количества посещенных узлов.
d807 1
a807 1
Здесь сортируются и подсчитываются вхождений для времени первого попадания, времени обхода и времени перемещения, используя вспомогательную функцию сортировки. Далее рассчитывается среднеее время первого попадания, среднее время обхода, среднее время перемещения и эффективное сопротивление.
a809 3
    sfh = sort_and_count(fht);
    sct = sort_and_count(ct);
    scmt = sort_and_count(cmt);
d818 2
a819 12
Определение вспомогательной функции, которая сортирует данные и подсчитывает вхождения. Возвращает матрицу с отсортированными данными и их количеством.

@@d sort function @@{
function sc = sort_and_count(data)
    [sorted_data, ~, idx] = unique(data);
    counts = accumarray(idx, 1);
    sc = [sorted_data, counts];
end
@@}

\section{Скрипт run_random_walk.m}
Для запуска функции random_walk и получения результатов был разработан скрипт run_random_walk. Этот скрипт задаёт параметры графа, запускает функцию random_walk и выводит результаты на экран.
d821 1
a821 1
@@d run_random_walk @@{
a824 3
@@< repeatable output hitting @@>
@@< repeatable output commute @@>
@@< repeatable output cover @@>
d826 1
a826 1
@@o run_random_walk.oc @@{@@< run_random_walk  @@>@@}
a839 1

d849 1
a849 1
[fht, ct, sfh, sct, mfht, mct, eff_res, mcmt, scmt] = random_walk(adj, start, end_, num_sim);
d857 4
a860 2
fprintf('Среднее время первого попадания в вершину %d из вершины %d: %f шага.\n', end_, start, mfht);
fprintf('Среднее время прохода из вершины %d в вершину %d и обратно: %f шага.\n', start, end_, mcmt);
a865 41

Следующий блок кода выводит детализированную информацию о повторениях времени для среднее время первого попадания.

@@d repeatable output hitting @@{
fprintf('Повторения времени первого попадания в вершину (в формате [время-количество]):\n');
    for i = 1:size(sfh, 1)
       fprintf('[%d-%d]', sfh(i, 1), sfh(i, 2));
       if i ~= size(sfh, 1)
           fprintf(', ');
       else
           fprintf('.\n');
       end
end
@@}

Этот блок кода выводит детализированную информацию о повторениях времени для среднее время прохода.
@@d repeatable output commute @@{
fprintf('Повторения времени прохода из вершины %d в вершину %d и обратно (в формате [время-количество]):\n', start, end_);
    for i = 1:size(sfh, 1)
       fprintf('[%d-%d]', scmt(i, 1), scmt(i, 2));
       if i ~= size(sfh, 1)
           fprintf(', ');
       else
           fprintf('.\n');
       end
end
@@}

А здесь выводится детализированную информацию о повторениях времени для среднее время обхода всего графа.
@@d repeatable output cover @@{
fprintf('Повторения времени обхода всего графа (в формате [время-количество]):\n');
    for i = 1:size(sfh, 1)
       fprintf('[%d-%d]', sct(i, 1), sct(i, 2));
       if i ~= size(sfh, 1)
           fprintf(', ');
       else
           fprintf('.\n');
       end
end
@@}

d890 1
a890 1
Стоит заметить, что при стократном увеличении тестов, результаты изменятся лишь на немного, что можно посчитать как погрешность
d893 1
a893 1
В качестве второго примера была взята матрица Московского метро, так как она позволяет проверить случайное блуждание в реальной транспортной сети. Начальная вершина была выбрана как вершина 1(станция Новокосино), а конечная вершина как вершина 442(станция Апрелевка). Количество тестов было установлено на 100000. Результаты тестов показали следующее:
d902 30
d987 1
a987 1
@@o laplacian.oc @@{@@< laplacian @@>@@}
d1020 1
a1020 1
Теперь нужно посчитать commute time, для этого воспользуемся формулой (5):
d1024 1
a1024 1
Нам осталось посчитать только hitting time, но так как считая эту форуму в ручную мы получим не совсем точные значения, то предлагаю воспользоваться формулой (5):
d1034 1
a1034 1
@@d theoretical_random_walk @@{
d1043 1
a1043 1
@@o theoretical_random_walk.oc @@{@@< theoretical_random_walk @@>@@}
d1048 6
a1053 1
file_path = 'moscow.txt';
d1085 1
a1085 1
Здесь начинаем подсчет времени выполнения. Затем создаем список соседей для каждой вершины. В каждой ячейке массива neighbors хранятся индексы соседей соответствующей вершины.
d1121 2
a1122 2
i = 1;
j = 421;
d1149 9
a1157 9
Эффективное сопротивление по результатам выполнения программы для рассчёта сопротивления равно 16, что с большой точностью совпадает с резульататом вычисления случайных блужданий.
Теоретически, среднее время коммутирования равно:
$$C^t_{(1,442)} = 2mR_{1,442} = 2 * 630 * 16 = 20160$$
Данные по результатам тестирования:
$$C^r_{(1,442)} = 20200$$
Результаты вычислений показывают, что среднее время прохождения из вершины 1 в вершину 442 и обратно почти точно удовлетворяет соотношению формулы (\ref{C_xy}).
$$C^t_{(1,442)} \approx C^r_{(1,442)}$$
Ошибка составлят 0,2\%.

d1159 12
a1173 2
%Программа показала свою пригодность для расчётов резистивного расстояния (эффективного сопротивления) между двумя произвольными узлами графа.
%Сохранение рассчитанной обратной матрицы Лапласиана позволяет сократить время выполнения программы на прежней матрице смежности.
d1193 1
a1193 1
        \item На языке Octave был разработаны алгоритмы для вычисления резистивного расстояния между двумя вершинами графа, а также алгоритм случайного блуждания. Программы обеспечивают универсальность использования, позволяют загружать матрицу смежности из файла и вычислять эффективное сопротивление и метрики случайных блужданий.
d1207 1
a1207 1
Разработанные алгоритмы и программы могут быть полезны в практике инженеров и исследователей, 
d1214 1
@


1.1
log
@Initial revision
@
text
@d6 2
a7 2
\RCS $Date: 2024/07/02 $
\RCS $Author: username $
d1243 1
a1243 1
 Разработанные алгоритмы и программы могут быть полезны в практике инженеров и исследователей, 
a1249 1

@
