\documentclass[utf8x]{G7-32}
\usepackage[T2A]{fontenc} % Кодировка шрифта
\usepackage{rcs}
\RCS $Revision: 1.3 $
\RCS $Date: 2024/07/12 11:38:49 $
\RCS $Author: lunk $

\usepackage{graphicx} % Для вставки изображений
\usepackage{amsmath} % Для использования математических формул
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{cancel}
\usepackage{tikz}
\usepackage{amsfonts} % Для использования математических символов и шрифтов
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage[strings]{underscore}
\usepackage{fancyvrb}
\newtheorem{theorem}{Теорема}[section]
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{corollary}[theorem]{Следствие}
\newtheorem{proposition}[theorem]{Утверждение}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Определение}
\newtheorem{example}[theorem]{Пример}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Замечание}




\include{preamble.inc}
\include{listings.inc}

\include{macros.inc}
\begin{document}


\NirOrgLongName{\textsc{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\\
	РОССИЙСКОЙ ФЕДЕРАЦИИ Федеральное государственное автономное\\
	образовательное учреждение высшего образования\\
	«Дальневосточный федеральный университет» \\
	ИНСТИТУТ МАТЕМАТИКИ И КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ\\
	ДЕПАРТАМЕНТ МАТЕМАТИЧЕСКОГО И КОМПЬЮТЕРНОГО\\
	МОДЕЛИРОВАНИЯ
	}}
\NirBoss{Директор ООО "Рога и Копыта"}{И.И.Иванов} %% Заказчик, утверждающий НИР

\NirManager{Профессор, д.ф-м.н.}{Е.А.Нурминский} %% Название организации

\NirYear{2024}%% если нужно поменять год отчёта; если закомментировано, ставится текущий год
\NirTown{г. Владивосток,} %% город, в котором написан отчёт
% по проекту \No8550:

% \NirIsAnnotacion{АННОТАЦИОННЫЙ } %% Раскомментируйте, если это аннотационный отчёт

\NirUdk{УДК \No 2123132123}
\NirGosNo{Регистрационный \No 123123}

%\NirStage{Этап \No 1.1}{промежуточный}{"Обзор современного состояния торсионных наногенераторов"} %%% Этап НИР: {номер этапа}{вид отчёта - промежуточный или заключительный}{название этапа}
\NirTitle{\textbf{"Случайные блуждания: связь с резистивным расстоянием"}} %%% Название НИР и генерация титульного листа

Revision: \RCSRevision, 
Date: \RCSDate, 
Author: \RCSAuthor  
\Executors{
\begin{itemize}
	\item Вершинин Д. А. \hfill \underline{\hspace{3cm}}
	\item Пелагеев Д. И. \hfill \underline{\hspace{3cm}}
	

  %[\item Вершинин Данил Алексеевич
  % Добавьте других исполнителей здесь
\end{itemize}}

\tableofcontents
\Defines % Список обозначений и сокращений в тексте
\begin{description}
	\item[Электрическая цепь] Набор электрических компонентов, таких как резисторы, конденсаторы и источники питания, соединённых проводниками для создания замкнутого пути, по которому может течь электрический ток.

	\item[Граф] Математическая структура, состоящая из вершин (узлов) $V$ и рёбер $E$, соединяющих пары вершин, используемая для моделирования различных систем и их взаимосвязей.

	\item[Вершина] Фундаментальный элемент в теории графов, представляющий объект или точку соединения в электрической цепи или другой сети. Также иногда называется узлом.

	\item[Ребро] Соединение между двумя вершинами графа, соответствующее электрическому сопротивлению в электрической цепи.

	\item[Резистивное расстояние] Эффективное сопротивление между двумя вершинами в графе, моделирующем электрическую цепь, когда все сопротивления заменены на единичные.

	\item[Законы Кирхгофа] Физические законы, описывающие сохранение электрического заряда и энергии в электрической цепи. Первый закон (Закон узлов) утверждает, что сумма токов, входящих в узел, равна сумме токов, выходящих из узла. Второй закон (Закон контуров) гласит, что сумма напряжений в любом замкнутом контуре цепи равна нулю.

	\item[Матрица смежности] Квадратная матрица, используемая для представления графа, где элементы указывают наличие или отсутствие рёбер между парами вершин.

	\item[Лапласиан] Квадратная матрица, вычисляемая на основе матрицы смежности графа, которая используется для анализа свойств графов и их спектров.

	\item[Обратная матрица Лапласиана] Матрица, полученная при обращении Лапласиана графа, используемая для вычисления резистивного расстояния между вершинами графа.

	\item[Обращение матрицы] Операция, при которой для данной квадратной матрицы \(A\) находится такая матрица \(A^{-1}\), что произведение \(A \cdot A^{-1}\) равно единичной матрице. Обратная матрица существует только для невырожденных (не сингулярных) матриц.

	\item[Случайное блуждание] Модель, описывающая случайное перемещение по вершинам графа, где вероятность перехода из одной вершины в другую определяется весами рёбер.

	\item[Сопротивление] Физическая величина, характеризующая способность проводника препятствовать прохождению электрического тока, измеряемая в омах (\(\Omega\)). Существует несколько способов расчета сопротивления:

		\begin{itemize}
		    \item \textbf{Закон Ома:} Сопротивление \(R\) можно определить как отношение напряжения \(U\) на проводнике к силе тока \(I\), протекающего через него: \(R = \frac{U}{I}\).
					        
   	            \item \textbf{Последовательное соединение резисторов:} Общее сопротивление \(R_{\text{сум}} \) для последовательного соединения резисторов определяется как сумма сопротивлений всех резисторов: \(R_{\text{сум}} = R_1 + R_2 + \ldots + R_n\).
							    
		    \item \textbf{Параллельное соединение резисторов:} Общее сопротивление \(R_{\text{п}} \) для параллельного соединения резисторов определяется как обратная величина суммы обратных значений сопротивлений всех резисторов: \(\frac{1}{R_{\text{п}}} = \frac{1}{R_1} + \frac{1}{R_2} + \ldots + \frac{1}{R_n}\).
						        
		    \item \textbf{Сопротивление проводника:} Сопротивление \(R\) проводника также можно вычислить по формуле: \(R = \rho \frac{L}{A}\), где \(\rho\) — удельное сопротивление материала, \(L\) — длина проводника, \(A\) — площадь его поперечного сечения.
		\end{itemize}

	\item[Напряжение] Разность электрических потенциалов между двумя точками электрической цепи, определяющая способность источника энергии выполнять работу по перемещению заряда, измеряемая в вольтах (В). 

	\item[Сила тока] Количество электрического заряда, проходящего через поперечное сечение проводника за единицу времени, измеряемая в амперах (А).


\end{description}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:

%\subsection{Разработка программы для вычисления резистивного расстояния в графах с использованием Octave}
\frontmatter
%\chapter{Введение}
\chapter{Введение}
\label{cha:vvedenie}
Теория графов часто применяется для исследования электрических цепей. 
Одной ее из задач является нахождение сопротивления между двумя узлами электрической сети.
Эту задачу можно рассматривать в контексте теории графов, т.к. электрическую цепь можно моделировать с помощью связного графа, где вершинами графа являются узлы сети.
Два узла сети являются смежными, если между ними существует прямая связь. Это означает, что между этими узлами существует физическое соединение.
Такому соединению можно сопоставить ребро графа, где его весом является электрическая проводимость между двумя узлами сети, взятых изолированно от остальной сети. 

С введением графовой интерпретации можно задать метрику для нахождения 
расстояния между двумя произвольными вершинами графа -- резистивное расстояние\cite{RD}. 
Резистивное расстояние между двумя вершинами простого связного графа G равно сопротивлению между двумя 
узлами электрической цепи, построенной путем замены сопротивления всех связей сети на сопротивление в 1 Ом.
В таком случае вес каждого ребра будет равен единице.
В то же время, для электрической цепи применим первый закон Кирхгофа : "Алгебраическая сумма токов в узле электрической цепи равна нулю". 

Связь между Законами Кирхгофа и резистивным расстоянием начали исследовать Douglas J. Klein и  M. Randic \cite{RD2} несколько десятилетий назад. 

В данной работе рассматривается модель электрической цепи, представленной в виде графа, где вершины графа соответствуют узлам электрической сети, 
а вес ребра графа — сопротивлениям между этими узлами, взятыми изолированно от основной сети. 
Главной целью является нахождение резистивного расстояния между двумя произвольными вершинами графа. 
Это расстояние эквивалентно сопротивлению между соответствующими узлами в электрической цепи. 
Модель позволяет использовать математические методы теории графов для анализа электрических цепей, что упрощает вычисления и интерпретацию результатов. 

Прикладной задачей является разработка алгоритма для вычисления резистивного расстояния, 
что открывает возможности для применения этой модели в различных областях, включая оптимизацию маршрутов и анализ сложных сетей.

Существует также тесная связь с методом случайных блужданий.
Этот метод основывается на предположении, что время перемещения по каждому ребру равно единице, а выбор следующей
вершины происходит случайно с равной вероятностью для всех соседей текущей вершины.
Случайное блуждание моделирует поведение тока в идеальных электрических цепях.
\mainmatter
\chapter{Теоретические аспекты электрических сетей}
Стоит отметить, что существует два вида закона Ома: линейный и нелинейный. 

Линейный закон Ома утверждает, что ток через проводник прямо пропорционален напряжению, приложенному к нему, при условии, 
что температура и другие физические условия остаются постоянными. Это выражается формулой:
$$I = \frac{U}{R},$$
где $I$ -- ток (в амперах, А), $U$ -- напряжение (в вольтах, В), $R$ -- сопротивление (в омах, Ом).

Нелинейный закон Ома описывает материалы и устройства, у которых нет прямой зависимости тока от напряжения. 
В таких случаях ток может изменяться при изменении напряжения или сопротивления нелинейно.
Формула нелинейного закона Ома часто значительно сложнее, чем линейный закон, и зависит от специфики материала или компонента. 
Для описания таких зависимостей обычно применяют эмпирические формулы.

Например, уравнение Шокли моделирует силу тока в полупроводниковых диодах \cite{shkl}:
$$I = I_S\left(e^{{U}/{nV_T}} - 1\right),$$
где $I$ -- искомый ток, $I_S$ -- обратный ток насыщения, $U$ -- напряжение, $n$ -- коэффициент качества, $V_T$ -- тепловое напряжение.

В работе рассматривается только линейный закон Ома.
\section{Физические определения}
\begin{definition}[Ток]
	Ток от вершины $x$ до $y$ графа $G$ определяется как функция $i$ на парах смежных вершин такая, что:
	\begin{equation}\label{tok1}
	i_{xy} = - i_{yx}
	\end{equation}
	Ток $i_{xy}$ определяется уравнением:
	\begin{equation}\label{tok2}
	\sum_y^{\sim x} i_{xy} = I\cdot \delta_{xa} - I\cdot \delta_{xb}, \ \forall x \in V(G)
	\end{equation}
	где сумма берется по всем $y\in V(G)$, смежным с вершиной $x$; $\delta_{xy}$ -- символ Кронекера. 
\end{definition}
Эта формула описывает сумму токов, входящих в вершину $x$. 
Величина $I\delta_{xa}$ равна $I$, если $x=a$ (источник), и 0 -- в противном случае. 
Аналогично, $I\delta_{xb}$ равно $I$, если $x=b$ (сток), и 0 -- в противном случае. 
Таким образом, $I$ представляет собой величину чистого тока, входящего из источника $a$ и выходящего в сток $b$.
Это уравнение известно как закон Кирхгофа для тока (в случае одного источника и одного стока).
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
% Nodes
		\node[draw, circle] (a) at (0,0) {$a$};
		\node[draw, circle] (x) at (0,2) {$x$};
		\node[draw, circle] (y) at (6,2) {$y$};
		\node[draw, circle] (b) at (6,0) {$b$};
				    
% Edges with currents
		\draw[->] (a) -- node[midway, left] {$i_{ax} = -i_{xa}$} (x);
		\draw[->] (x) -- node[midway, above] {$i_{xy} = -i_{yx}$} (y);
		\draw[->] (y) -- node[midway, right] {$i_{yb}$} (b);
		\draw[->] (a) -- node[midway, below] {$i_{ab}$} (b);
		\draw[->] (x) --  (a);
		\draw[->] (y) --  (x);

% Potentials
		\node at (0,-0.6) {$v_a$};
		\node at (0,2.6) {$v_x$}; 
		\node at (6,2.6) {$v_y$};
		\node at (6,-0.6) {$v_b$};
										        
% Resistances
		\node at (1,1) {$r_{ax}$};
		\node at (3,1.5) {$r_{xy}$};
		\node at (5,1) {$r_{yb}$};
	\end{tikzpicture}
	\caption{Иллюстрация формул (\ref{tok1}) и (\ref{tok2})}
	\label{fig:graph}
\end{figure}
\begin{definition}[Физический ток]
	Ток называют физическим \cite{RD2}, если существует потенциал-функция $v$ на вершинах графа $G$ такая, что:
	\begin{equation}\label{tok3}
	i_{xy}\cdot r_{xy} = v_x - v_y, \ \forall x,y \in E(G),
	\end{equation}
	где $r_{xy} \equiv r_{e}$, при $e=\{x,y\}$. 
\end{definition}
Потенциал-функция известна как напряжение (аналог давления в гидравлике), а уравнение (\ref{tok3}) также известно как закон Ома.
Для тока в графе  $G$ существование такой потенциал-функции может быть показано через второй закон Кирхгофа для цепей:
\begin{equation}\label{tok4}
	\sum_{x\sim y}^C i_{xy}r_{xy} = 0, \ \forall C
\end{equation}
где сумма берется по всем ребрам контура $C$ в графе $G$, а ток $i$ из упорядоченной последовательности токов контура $C$. 

\section{Нормированное пространство}
В соответствии с графом $G$ можно определить нормированное пространство с ортонормированным базисом, элементы которого сопоставлены с вершинами графа $G$.
Такой базисный вектор определяется как $|x\rangle, x \in V(G)$. 
В этом пространстве представлены несколько матриц (линейных операторов).
\begin{definition}[Матрица инцидентности]
	Матрицей инцидентности называется матрица, элементы которой задаются следующим образом:
	\begin{equation}\label{tok5}
	A_{xy} = \langle x|A|y\rangle = 
	\begin{cases}
		1/r_{xy}, & x  \sim y\\
		0, & otherwise
	\end{cases} \ x,y \in V(G) 
\end{equation}
\end{definition}
При установлении единичных сопротивлений в цепи, матрица \( A \) сводится к матрице смежности графа \( G \).

\begin{definition}[Матрица степеней]
	Матрица $\Delta$,  элементы которой задаются следующим образом:
	\begin{equation}\label{tok6}
		\Delta_{xy} = \langle x|\Delta|y\rangle=\delta_{xy}\sum_z^{\sim x}1/r_{xz}
	\end{equation}
	где суммирование происходит по вершинам $z\in V(G)$, которые смежны с $x$, называется матрицей степеней вершин. 
\end{definition}

Далее большую роль сыграет матрица под названием Лапласиан, которая задаётся через разность $\Delta - A$. 

\begin{lemma}[О собственных значениях]
	Лапласиан имеет неотрицательные собственные значения, минимум одно из которых ноль. 
	Если граф $G$ связный, то соответствующий собственный вектор (с точностью до скалярного множителя) равен:
	\begin{equation}\label{tok7}
		|\phi\rangle \equiv \sum_x |x\rangle,
	\end{equation}
\end{lemma}

Для уменьшения размера работы доказательство опускается. Оно представлено в \cite{RD2} см. 86 стр. 

\begin{corollary}
	По условиям леммы, Лапласиан имеет как минимум одно собственное значение равное нулю. 
	Следовательно, он не является обратимым в привычном смысле.
	Однако в подпространстве, ортогональном к $|\phi\rangle$, он действительно имеет обратную матрицу.
\end{corollary}
Матрица, равная на этом подпространстве обратной и в остальных случаях равная нулю, обозначается как $Q/(\Delta - A)$, где 
$Q$ — это (эрмитовый или идемпотентный) проекционный оператор:
\begin{equation}\label{tok8}
	Q = 1 - \frac{1}{\langle\phi | \phi\rangle} |\phi\rangle \langle\phi|
\end{equation}

\begin{definition}[Обобщенная обратная матрица Лапласиана]
	Результирующая матрица $\{Q/(\Delta - A)\}$, удовлетворяющая условиям
	\begin{equation}
	\{Q/(\Delta - A)\}(\Delta - A) = (\Delta - A)\{Q/(\Delta - A)\} = Q, 
	\end{equation}
	\begin{equation}
		\{Q/(\Delta - A)\}Q = Q\{Q/(\Delta - A)\} = \{Q/(\Delta - A)\} 
	\end{equation}
	называется обобщенной обратной матрицей Лапласиана.
\end{definition}
\section{Эффективное сопротивление}

\begin{lemma}[О токе]
	Физический ток в графе $G$ из вершины $a$ в вершину $b$ в связном графе существует, является единственным и определяется следующим образом:
	\begin{equation}\label{tok10}
		i_{xy} = \frac{I}{r_{xy}}\langle x -y| Q/(\Delta - A)| a-b\rangle,
	\end{equation}
	где $|a-b\rangle \equiv |a\rangle - |b\rangle$.		
\end{lemma}

\begin{proof}
	Для доказательства, подставим (\ref{tok3}) в (\ref{tok2}) и получим:
	\begin{equation}\label{tok11}
		\sum_y^{\sim x}\frac{1}{r_{xy}} \{v_x - v_y\} = I\delta_{xa} - I\delta_{xb}
	\end{equation}
	Используя (\ref{tok6}) и (\ref{tok5}), получим:
	\begin{equation}\label{tok12}
	\langle x| \Delta | x \rangle v_x - \sum_y \langle x | A | y \rangle v_y = I\langle x | a -b \rangle
	\end{equation}
	Теперь $\forall x \in V(G)$, это можно переписать как:
	\begin{equation}\label{tok13}
	(\Delta - A)\sum_x v_x|x\rangle  = I\langle x | a - b\rangle. 
	\end{equation}
	Тогда, согласно лемме о собственных значениях, (\ref{tok13}) можно переписать как: 
	\begin{equation}\label{tok14}
	\sum_x v_x|x\rangle = I\{Q/(\Delta - A)\} |a-b\rangle + c|\phi\rangle, 
	\end{equation}
	где $c$ еще не определенная константа. Это непосредственно приводит к формуле нашей теоремы, тем самым устанавливая уникальность этих различий. 
	Разность потенциалов между парой вершин $x,y$ дает нам
	\begin{equation}\label{tok15}
	v_x - v_y = I\langle x -y|Q/(\Delta - A) |a-b\rangle
	\end{equation}
	Тогда, закон Ома (\ref{tok3}) дает формулу леммы, единственность $I$ и его существование.
\end{proof}

Разность потенциалов между двумя точками, как видно из (\ref{tok6}), прямо пропорциональна $I$. 
При выборе $x=a$ и $y=b$, этот коэффициент пропорциональности называется эффективным сопротивлением $\Omega_{ab}$ между $a$ и $b$. 
Таким образом, мы получаем основной результат этого раздела:

\begin{theorem} [О резистивном сопротивлении]
	Для физического тока из $a$ в $b$ в графе $G$:
	\begin{equation}
		\Omega_{ab} = \langle a-b|Q/(\Delta - A)| a -b\rangle
	\end{equation}
\end{theorem}


\begin{theorem}[Сопротивление эквивалентно расстоянию]
		Формально определим эффективное сопротивления как расстояние.
		Под расстоянием на графе $G$ мы понимаем отображение $\rho$ из декартова произведения $V(G)\times V(G)$ в вещественные числа, удовлетворяющее следующим аксиомам:
		\[\rho(a,b) \ge 0,\]
		\[\rho(a,b) =0 \Leftrightarrow a =b,\]
		\[\rho(a,b) = \rho(b,a),\]
		\[\rho(a,x) = \rho(x,b) \ge \rho(a,b)\]
\end{theorem}
Доказательство приведено в \cite{RD2} см. 89 стр.



\chapter{Теоретические основы случайных блужданий}
\label{cha:theory}

Случайное блуждание на графе \(G\) представляет собой процесс, при котором на каждом шаге изменяется состояние случайного процесса, заключающееся в перемещении из текущей вершины в одну из соседних вершин, выбранную независимым образом с равной вероятностью. 

Цель изучения случайных блужданий заключается в их универсальности и применимости к широкому спектру задач в науке и технике. 
Они предоставляют мощные инструменты для моделирования, анализа и решения сложных проблем, связанных с неопределенностью и случайностью.

Рассмотрим однородное случайное блуждание, при котором вероятность перехода из вершины $x$ в любую соседнюю вершину одинакова и равна \(1/d(x)\), 
где $d(x)$ - степень вершины $x$. 

Для начала определим сценарий, который будет полезен в доказательстве нескольких теорем.

\begin{definition}[Сценарий А]
	Подадим на каждый узел сети напряжение, равное количеству связей этого узла ($d(x)$). 
	Выберем узел $y$ и получим из него ток, равный $2m = \sum_x d(x)$, где $m$ - количество связей в сети.  
	Выбор количества тока обусловлен тем фактом, что сумма количества связей каждой вершины даст число, равное удвоенному количеству связей в цепи.
\end{definition}

Также введём следующие определения.

\begin{definition}[Время попадания]
	Для любых двух вершин $x$ и $y$  графа $G$ время попадания (hitting time) определяется, 
	как мат ожидание или же среднее количество шагов (steps) случайного блуждания, 
	необходимое для достижения вершины $y$ из вершины $x$.
	$$H_{xy} = {\mathbb{E}} [steps]$$
\end{definition}

\begin{definition}[Время возвращения]
	Время возвращения (commute time) $C_{xy}$ между двумя вершинами $x$ и $y$ в графе $G$ является мато жидание или же 
	среднее количество шагов (steps) случайного блуждания, 
	необходимое для прохождения пути из вершины $x$ в вершину $y$ и обратно.
	$$C_{xy} = H_{xy} + H_{yx}$$
\end{definition}

\begin{theorem}[Время первого попадания]
	При сценарии А
	разность потенциалов $\phi_{xy}$ между узлами $x$ и $y$ равна среднему времени попадания в вершину \(y\) из вершины \(x\) ($H_{xy}$):

\begin{equation}\label{phi}
    \phi_{xy} = H_{xy}
\end{equation}

\end{theorem}

\begin{proof}
Выберем начальный узел $x$ и конечный узел $y$.
В соответствии со вторым законом Кирхгофа, законом Ома и тем фактом, что все сопротивления проводников равны единице, имеем следующее:

\begin{equation}\label{d_x_1}
	d(x) = \sum_{z}^{\sim x} (\phi_{xy} - \phi_{zy})
\end{equation}
	Разложим сумму разности на разность сумм.
	Заметим, что  $\phi_{xy}$ не зависит от индекса z. 
	Следовательно, суммирование $\phi_{xy}$ будет производиться столько раз, какую степень имеет вершина $x$. Тогда,(\ref{d_x_1}) можно переписать:

\begin{equation}\label{d_x_2}
	d(x) = d(x) \cdot \phi_{xy} - \sum_{z}^{\sim x} \phi_{zy}
\end{equation}

	Решая уравнение, относительно $\phi_{xy}$, получим следующее:
	\begin{equation}\label{d_x_3}
		\phi_{xy} = 1 + \frac{1}{d(x)} \sum_{z}^{\sim x} \phi_{zy}
	\end{equation}
	Введем дополнительное условие для случая $x=y$:

\begin{equation}\label{phi_(xy)}
	\phi_{xy} = 
	\begin{cases} 
		0 & x = y \\
		1 + \frac{1}{d(x)} \sum\limits_{z}^{\sim x} \phi_{zy} &  x \neq y
	\end{cases} 
\end{equation}

	Из курса теории вероятности очевидно, что среднее время попадания из вершины $x$ в вершину $y$ ($H_{xy}$) 
	равно среднему времени попадания из смежных с $x$ вершин до вершины $y$ плюс один (один шаг до смежной вершины). 

\begin{equation}\label{H_xy}
	H_{xy} = 1 + \frac{1}{d(x)} \sum_{z}^{\sim x} H_{zy}
\end{equation}


	Установим условия для $x=y$
\begin{equation}\label{H_(xy)}
	H_{xy} = 
	\begin{cases} 
		0 & x = y \\
		1 + \frac{1}{d(x)} \sum\limits_{z}^{\sim x} H_{zy} &  x \neq y
	\end{cases} 
\end{equation}
	Заметим, что формулы (\ref{phi_(xy)}) и (\ref{H_(xy)}) идентичны, т.к. являются линейными системами с единственным решением.
	Следовательно, получим:

	\begin{equation}\label{H_xy_end}
		H_{xy} = \phi_{xy}
	\end{equation}

\end{proof}


Введём следующие определения.
\begin{definition}[Сценарий B]
	Сценарий B является схожим со сценарием A, за исключением того, что ток снимается с вершины $x$. 
	Обозначим разность потенциалов сценария B за $\phi_{yx}'$.

	Используя теорему о времени первого попадания, сценарий B можно записать, как
	$$\phi_{y,x}' = H_{yx} $$
\end{definition}
\begin{definition}[Сценарий C]
	Подадим напряжение, равное $2m$ на узел $x$, где $m$ - количество связей цепи.
	Ток будем снимать со всех узлов сети.
	Обозначим разность потенциалов сценария C за $\phi_{xy}''$.

	Данный сценарий является обратным к сценарию B, т.к. изменение затронуло только направление тока в сети.
	Поэтому мы получили:
	$$\phi_{xy}''=\phi_{yx}' = H_{yx} $$
\end{definition}

Основываясь на этих определениях и теореме о времени первого попадания докажем следующую теорему.
\begin{theorem}[Время возвращения]

	Время возвращения из вершины $x$ через вершину $y$ графа $G$ равно удвоенному количеству ребер (\(m\)) графа $G$,
	умноженному на эффективное сопротивление \(R_{xy}\)\cite{3}.

\begin{equation}\label{C_xy}
C_{xy} = 2mR_{xy}
\end{equation}

\end{theorem}

\begin{proof}
	Для доказательства этой теоремы используем сумму сценариев A и C. 
	Другими словами, подадим ток $2m$ на вершину $x$ и снимем его с вершины $y$.
	Обозначим разность потенциалов в этом случае за $\phi_{xy}'''$
	$$\phi_{xy} '''= \phi_{xy} + \phi_{yx}''$$
	По теореме о времени попадания и исходя из определения сценариев A и C получим:
	$$\phi_{xy} '''= H_{xy} + H_{yx}$$
	Заметим, что $\phi_{xy}'''$ является разностью потенциалов для перемещения тока $2m$ из узла  $x$ в узел $y$. 
	Используя закон Ома имеем:
	$$\phi_{xy}''' = 2mR_{xy}.$$
	Тогда получаем 
	\begin{equation}\label{C_xy_end}
		H_{xy} + H_{yx} = 2mR_{xy} \Rightarrow C_{xy} =  2mR_{xy}
	\end{equation}

\end{proof}

\chapter{Программа для расчета эффективного сопротивления с помощью законов Кирхгофа}
Для разработки программы был выбран язык программирования Octave\cite{octv1},
специально предназначенный для математических вычислений и являющейся бесплатной альтернативой
MATLAB\cite{matlb}.

Основные задачи заключались в следующем:

\begin{enumerate}
	\item Обеспечение универсальности (выбор файла с матрицей смежности графа, а также начального и конечного узлов).
	\item Расчет резистивного расстояния между двумя произвольными вершинами графа.
	\item Измерение времени выполнения программы.
\end{enumerate}

Cкрипт {\tt mainKirg} на языке Octave, приведенный ниже.

@d mainKirg @{
@< start-up: input and prelimnary data check  @>
@< compute main part @>
@< compute resistance-distatnce @>
@< display results @>
@}
@o mainKirg.m @{@< mainKirg @>@}
\section{Ввод и предварительная проверка данных}

Начальный фрагмент определяет исходные данные задачи.
Одним из ключевых аспектов являлась универсальность использования, что требовало реализации ввода имени файла для чтения и номеров узлов.

Здесь проверяется количество переданных параметров.
В случае если их недостаточно, программа завершает работу с сообщением об ошибке.
Далее происходит парсинг параметров: первый — имя файла, второй — начальный узел, третий — конечный узел.
После происходит проверка введенных параметров на корректность.
В случае неправильных данных вызывается ошибка с пояснением.
Запускается таймер выполнения программы.
В случае, если переданный файл уже обрабатывался, данные загрузятся из сохранённого файла.
Иначе выполняется блок кода "compute main part".

@d start-up: input and prelimnary data check  @{
args = argv();
if numel(args) < 3
	error('Необходимо указать имя файла с матрицей смежности и', 
		'номера двух узлов.');
end
filename = args{1};

a = str2double(args{2});
b = str2double(args{3});
if isnan(a) || isnan(b) || a <= 0 || b <= 0 
	error('Номера узлов должны быть положительными целыми ',
		'числами.');
endif

tic;
[~, name, ~] = fileparts(filename);
pseudo_inverse_filename = [name, '_L_plus.mat'];

if exist(pseudo_inverse_filename, 'file') == 2
    	load(pseudo_inverse_filename, 'L_plus');
    	disp(['Псевдообратная матрица Лапласа загружена из файла ', 
		pseudo_inverse_filename, '.']);
	n = size(L_plus, 1);
@}

\section{Основные расчеты}
Этот блок отвечает за тяжеловесные расчеты программы.

Cчитывается матрица смежности из указанного файла.
Подсчитывается количество вершин.
Вычисляются степени вершин, и создается диагональная матрица степеней.

Затем вычисляется матрица Лапласиана.
Происходит проверка корректности вычисления псевдообратной матрицы.
Вычисляется псевдообратная матрица Лапласиана.
Результат вычислений записывается в специальный файл.
Считывание псевдообратной матрицы из этого файла позволит сократить время расчёта при очередном запуске программы с той же матрицей смежности.
@d compute main part  @{
else
	A = dlmread(filename);
	n = size(A, 1);

	
	D = diag(sum(A, 2));
	L = D - A;
	if rank(L) < n-1
		error('Матрица Лапласиана не имеет полного ранга.');
	end
	L_plus = pinv(L);
	save(pseudo_inverse_filename, 'L_plus');
	disp(['Псевдообратная матрица Лапласа вычислена и ',
		'сохранена в файл ', pseudo_inverse_filename, '.']);
end
@}
\section{Расчет разницы потенциалов}
Проверяется, что указанные узлы существуют в матрице.
Создается результирующий вектор h и производится расчет резистивного расстояния (эффективного сопротивления).
Для оптимизации программы эти действия записаны в одну строчку.
@d compute resistance-distatnce @{
if a > n || b > n
	error('Номера узлов выходят за пределы размерности ',
		'матрицы.');
endif

answer = (L_plus(a, a) - L_plus(b, a)) - (L_plus(a, b) - 
	L_plus(b, b));
@}
\section{Вывод результата}

Остановка таймера выполнения и вывод результата:
@d display results @{
elapsed_time = toc;
disp("===========================================================");
disp(['Резистивное расстояние между узлами ', num2str(a), ' и ',
	 num2str(b), ': ', num2str(answer)]);
disp(['Время выполнения программы: ', num2str(elapsed_time), 
	' секунд']);
@}

\chapter{Тестирование программы}

Программа была протестирована на различных графах в три этапа:
\begin{enumerate}
	\item Проверка правильности работы алгоритма на малых графах (до 5 вершин, заполненность 100\%).
	\item Тестирование на графах средних размеров (100-600 вершин, заполненность 90\%).
	\item Тестирование на больших графах (1000 и более вершин, заполненность 25-90\%).
\end{enumerate}
Данные для тестирования использовались без подгрузки предрасчитанной псевдообратной матрицы.

\section{Результаты тестирования}
\begin{itemize}
	\item Малые графы: алгоритм выдает решение менее чем за сотую долю секунды.
	\item Средние графы: время выполнения менее полусекунды для графов с количеством вершин менее 500. При 500-600 вершинах расчет занимает 3.5 секунды.
	\item Большие графы: для графа с 1000 вершинами и заполненностью 90\% расчет занимает 6.5 секунд. Граф с 3000 вершинами и заполненностью 25\% рассчитывается за 500 секунд. Больше данных изображено на Рис. 4.1
\end{itemize}
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			width=\textwidth,
			height=0.6\textwidth,
			xlabel={Количество вершин},
			ylabel={Время работы программы},
			xlabel style={yshift=-10pt},
			tick label style={font=\small, rotate=45, anchor=east}
			]
			\addplot coordinates {
				(5,0.01) (100,0.013) (300, 0.3) (600,3.7) (1000, 6.5) (1500, 70) (2000, 142) (2500, 333) (3000, 500)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения программы от количества вершин в графе}
\end{figure}

Основное время выполнения программы приходится на вычисление псевдообратной матрицы (сложность $O(n^3)$). 
Поэтому, время выполнения увеличивается на три порядка при увеличении размера графа в 10 раз. 


\chapter{Реализация программы случайного блуждания}

\section{Переменные}
\subsection{Входные переменные}

\begin{itemize}
    \item \texttt{adj} - матрица смежности графа.
    \item \texttt{start} - индекс начального узла.
    \item \texttt{end_} - индекс конечного узла.
    \item \texttt{num_sim} - количество тестов.
\end{itemize}

\subsection{Выходные переменные}

\begin{itemize}
    \item \texttt{fht} - вектор, содержащий время первого попадания в конечный узел для каждого теста.
    \item \texttt{ct} - вектор, содержащий время полного обхода графа для каждого теста.
    \item \texttt{cmt} - вектор, содержащий время перемещения от начального узла к конечному и обратно для каждого теста.
    \item \texttt{sfh} - отсортированный вектор времени первого попадания и их количества.
    \item \texttt{sct} - отсортированный вектор времени полного обхода графа и их количества.
    \item \texttt{scmt} - отсортированный вектор времени перемещения и их количества.
    \item \texttt{mfht} - среднее время первого попадания в конечный узел.
    \item \texttt{mct} - среднее время полного обхода графа.
    \item \texttt{mcmt} - среднее время перемещения от начального узла к конечному и обратно.
    \item \texttt{eff_res} - эффективное сопротивление графа, рассчитанное как среднее время перемещения, деленное на удвоенное количество ребер.
\end{itemize}

\subsection{Промежуточные переменные}

\begin{itemize}
    \item \texttt{n} - количество узлов в графе.
    \item \texttt{m} - количество ребер в графе, рассчитанное как половина суммы всех элементов матрицы смежности.
    \item \texttt{curr} - текущий узел в процессе блуждания.
    \item \texttt{visited} - булевый вектор, указывающий, были ли посещены узлы.
    \item \texttt{steps} - количество шагов, сделанных в текущем тесте.
    \item \texttt{first_hit} - булева переменная, указывающая, было ли достигнуто первое попадание в конечный узел.
    \item \texttt{visit_count} - количество посещенных узлов.
    \item \texttt{neighbors} - вектор соседних узлов для текущего узла.
    \item \texttt{next} - следующий узел для перехода.
    \item \texttt{cms} - количество шагов для перемещения от начального узла к конечному и обратно в текущем тесте.
    \item \texttt{file_path} - путь к файлу с матрицей смежности.
    \item \texttt{elapsed_time} - время, затраченное на выполнение тестов.
\end{itemize}

\section{Скрипт random walk.m}
В данной работе была разработана программа на языке Octave, которая имитирует случайные блуждания по графу, заданному матрицей смежности. Программа рассчитывает статистические данные. Об этих данных ниже рассказано более подробно. 


@d random walk @{
function [fht, ct, mfht, mct, eff_res, ...
mcmt] = random_walk(adj, start, end_, num_sim)
@< initialization of variables @>
@< simulation loop @>
@< calculation @>
@}
@o random_walk.m @{@< random walk  @>@}



В этом блоке инициализируются переменные для количества узлов и ребер в графе, векторов для хранения времени первого попадания, времени полного обхода, и времени перемещения.

@d initialization of variables @{
    n = size(adj, 1);
    m = sum(adj(:)) / 2;
    fht = zeros(num_sim, 1);
    ct = zeros(num_sim, 1);
    cmt = zeros(num_sim, 1);
@}

Этот блок выполняет цикл по числу тестов для выполнения случайных блужданий.

@d simulation loop @{
@< initialising the current state @>
@< graph wandering cycle @>
@< hit check @>
@< update visited nodes @>
@< record round-trip time @>
@< calculation of travel time @>
@}

Этот блок начинает наш основной цикл, инициализируя текущий узел как начальный узел , а также массивы для отслеживания посещенных узлов и количества шагов. Также инициализируются переменные для отслеживания первого попадания в конечный узел и количества посещенных узлов.

@d initialising the current state @{
    for sim = 1:num_sim
        curr = start;
        visited = false(n, 1);
        visited(start) = true;
        steps = 0;
        first_hit = false;
        visit_count = 1;
@}

Этот цикл продолжается до тех пор, пока не будут посещены все узлы графа. Внутри цикла определяется следующий узел для перехода случайным образом из соседей текущего узла.

@d graph wandering cycle @{
        while visit_count < n
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            steps = steps + 1;
            curr = next;
@}

Если это первое попадание в конечный узел, сохраняется количество шагов до первого попадания.

@d hit check @{
            if ~first_hit && curr == end_
                fht(sim) = steps;
                first_hit = true;
            end
@}

Если узел еще не был посещен, он помечается как посещенный, и увеличивается счетчик посещений.

@d update visited nodes @{
            if ~visited(curr)
                visited(curr) = true;
                visit_count = visit_count + 1;
            end
        end
@}

После завершения обхода всех узлов записывается количество шагов.

@d record round-trip time @{
        ct(sim) = steps;
@}

Затем рассчитывается время перемещения от начального узла к конечному и обратно. Это выполняется двумя циклами: один до конечного узла, и один обратно к начальному узлу.

@d calculation of travel time @{
        cms = 0;
        curr = start;
        while curr ~= end_
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            cms = cms + 1;
            curr = next;
        end
        while curr ~= start
            neighbors = find(adj(curr, :));
            next = neighbors(randi(length(neighbors)));
            cms = cms + 1;
            curr = next;
        end
        cmt(sim) = cms;
    end
@}

Здесь рассчитывается среднее время первого попадания, среднее время обхода, среднее время перемещения и эффективное сопротивление.

@d calculation @{
    mfht = mean(fht);
    mct = mean(ct);
    mcmt = mean(cmt);

    eff_res = mcmt / (2 * m);
end
@}

\section{Скрипт run random walk.m}
Для запуска функции random walk и получения результатов был разработан скрипт run random walk. Этот скрипт задаёт параметры графа, запускает функцию random walk и выводит результаты на экран.

@d run random walk @{
@< parameters set-up @>
@< running simulation@>
@< main results output @>
@}
@o run_random_walk.m @{@< run random walk @>@}

Указание пути к файлу с матрицей смежности, начального узла, конечного узла и числа тестов. Затем чтение матрицы смежности из указанного файла с помощью функции \texttt{dlmread} и сохранение в переменную матрицы смежности.

@d parameters set-up @{
args = argv();
if numel(args) < 3
        error('Необходимо указать имя файла с матрицей смежности и',
                'номера двух узлов.');
end

file_path = args{1};
start = str2double(args{2});
end_ = str2double(args{3});
num_sim = 1000;

adj = dlmread(file_path);
@}

Выполнение функции случайного блуждания с заданными параметрами и измерение затраченного времени с помощью \texttt{tic} и \texttt{toc}. Результаты сохраняются в соответствующих переменных, а время выполнения - в переменной \texttt{elapsed_time}.

@d running simulation @{
tic;
[fht, ct, mfht, mct, eff_res, mcmt] = random_walk(adj, start, end_, num_sim);
elapsed_time = toc;
@}


Этот блок кода выводит основные результаты вычислений, такие как: среднее время первого попадания, среднее время прохода, среднее время обхода всего графа, эффективное сопротивление, время выполнения программы

@d main results output  @{
fprintf('Среднее время первого попадания в вершину %d из' ,
	'вершины %d: %f шага.\n', end_, start, mfht);
fprintf('Среднее время прохода из вершины %d в вершину %d и' , 
	'обратно: %f шага.\n', start, end_, mcmt);
fprintf('Среднее время обхода всего графа: %f шага.\n', mct);
fprintf('Эффективное сопротивление: %f.\n', eff_res);
fprintf('Время выполнения программы: %f секунд.\n', elapsed_time);
@}

\chapter{Результаты и их анализ}
\section{Проведение тестов}

В качестве примеров мы рассмотрим два графа. Первый граф будет тестовым для понимания методологии решения, а вторым графом является Московское метро.

\subsection{Пример 1}
\[
\text{adj_matrix} = \begin{pmatrix}
0 & 1 & 1 & 0 \\ 
1 & 0 & 1 & 1 \\ 
1 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 
\end{pmatrix}
\]

Начальная вершина была выбрана как вершина 1, а конечная вершина как вершина 4. Количество тестов было установлено на 1000. Результаты тестов показали следующее:

\begin{itemize}
    \item Среднее время первого попадания в вершину 4 из вершины 1: 5.047200 шага.
    \item Среднее время прохода из вершины 1 в вершину 4 и обратно: 10.004400 шага.
    \item Среднее время обхода всего графа: 5.934400 шага.
    \item Эффективное сопротивление: 1.000440.
    \item Время выполнения программы: 7.940940 секунд.
\end{itemize}
Стоит заметить, что при стократном увеличении тестов, результаты изменятся незначительно.

\subsection{Пример 2}
В качестве второго примера была взята матрица Московского метро (442 вершины, 630 ребер), так как она позволяет проверить случайное блуждание в реальной транспортной сети. Начальная вершина была выбрана как вершина 1(станция Новокосино), а конечная вершина как вершина 442(станция Апрелевка). Количество тестов было установлено на 100000. Результаты тестов показали следующее:
\begin{itemize}
    \item Среднее время первого попадания в вершину 442 из вершины 1: 17159.75 шага.
    \item Среднее время прохода из вершины 1 в вершину 442 и обратно: 20142.68 шага.
    \item Среднее время обхода всего графа: 40777.67 шага.
    \item Эффективное сопротивление: 15.99.
    \item Время выполнения программы: 3194.03 секунд.
\end{itemize}

Эффективное сопротивление по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 16.
Тогда из формулы (\ref{C_xy}) следует, что среднее время коммутирования равно:
$$C^t_{(1,442)} = 2mR_{1,442} = 2 * 630 * 16 = 20160$$
Среднее время коммутирования по результатам случайных блужданий:
$$C^r_{(1,442)} \approx 20142$$
Результаты вычислений показывают, что среднее время прохождения из вершины 1 в вершину 442 и обратно почти точно удовлетворяет соотношению формулы (\ref{C_xy}).
$$C^t_{(1,442)} \approx C^r_{(1,442)}$$
Ошибка составлятет 0,01\%.


\subsection{Пример 3}
Третьим примером стал линейный граф с количеством вершин 442 и количеством ребер 441. Количество тестов было установлено на 10000.
\begin{itemize}
    \item Среднее время первого попадания в вершину 442 из вершины 1: 191980.58 шага.
    \item Среднее время прохода из вершины 1 в вершину 442 и обратно: 389058.45 шага.
    \item Среднее время обхода всего графа: 191980.58.
    \item Эффективное сопротивление: 441.11.
    \item Время выполнения программы: 32729.89 секунд.
\end{itemize}
Эффективное сопротивление по результатам выполнения программы для расчёта сопротивления с помощью законов Киргхофа равно 441.
Тогда из формулы (\ref{C_xy}) следует, что среднее время коммутирования равно:
$$C^t_{(1,442)} = 2mR_{1,442} = 2 * 441 * 441 = 388962$$
Среднее время коммутирования по результатам случайных блужданий:
$$C^r_{(1,442)} \approx 389058.45$$
Результаты вычислений показывают, что среднее время прохождения из вершины 1 в вершину 442 и обратно достаточно точно удовлетворяет соотношению формулы (\ref{C_xy}).
$$C^t_{(1,442)} \approx C^r_{(1,442)}$$
Ошибка составлятет 0,03\%.



\section{Теоретические расчеты}
\subsection{Пример 1}
Теперь с помощью теории рассчитаем количество шагов до попадания в вершину 4 из вершины 1. Составим матрицу степеней из матрицы смежности, используемой выше:
\[
\text{D} = \begin{pmatrix}
2 & 0 & 0 & 0 \\ 
0 & 3 & 0 & 0 \\ 
0 & 0 & 3 & 0 \\
0 & 0 & 0 & 2 
\end{pmatrix}
\]

Из этих двух матриц составим матрицу Лапласа (Лапласиан), используя данную формулу: {L = D - adj_matrix}
\[
\begin{pmatrix}
2 & 0 & 0 & 0 \\ 
0 & 3 & 0 & 0 \\ 
0 & 0 & 3 & 0 \\
0 & 0 & 0 & 2 
\end{pmatrix}
-
\begin{pmatrix}
0 & 1 & 1 & 0 \\ 
1 & 0 & 1 & 1 \\ 
1 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 
\end{pmatrix}
=
 \begin{pmatrix} 
2 & -1 & -1 & 0 \\ 
-1 & 3 & -1 & -1 \\ 
-1 & -1 & 3 & -1 \\
0 & -1 & -1 & 2 
\end{pmatrix} = \text{L}
\]

Далее мы получаем собственные значения и собственные вектора матрицы Лапласа, чтобы их получить я воспользуюсь Octave:

@d laplacian @{
laplacian_matrix = [2 -1 -1 0;                
                   -1 3 -1 -1;
                   -1 -1 3 -1;
                    0 -1 -1 2];


[eigenvectors, eigenvalues_matrix] = eig(laplacian_matrix);

eigenvalues = diag(eigenvalues_matrix);

disp('Собственные значения:');
disp(eigenvalues);

disp('Собственные вектора:');
disp(eigenvectors);
@}
@o laplacian.m @{@< laplacian @>@}


Где eigenvalues – это \(\lambda_k\), а eigenvectors –  это  \(u_{i}\)

$$\lambda_1 = 0, \quad \lambda_2 = 2, \quad \lambda_3 = 4, \quad \lambda_4 = 4$$

\[
\text{U} =  \begin{pmatrix} 
-0.50 & -0.71 & 0.49 & 0.09 \\
-0.50 & 0.00 & -0.62 & 0.60 \\
-0.50 & 0.00 & -0.36 & -0.79 \\
-0.50 & 0.71 & 0.49 & 0.09 \\
\end{pmatrix} 
\]



У собственных значений убираем нулевое значения и берем нулевую и третью строки из матрицы \(U\) для расчета \(R_{14}\). Получаем следующее:
$$ \lambda_2 = 2, \quad \lambda_3 = 4, \quad \lambda_4 = 4 $$
$$ u_0  = (-0.50, -0.71, 0.49, 0.09)$$
$$ u_3  = (-0.50, 0.71, 0.49, 0.09)$$

Теперь нам нужны значения \(n\) и \(m\). У нас \(n\) уже известна, она равна 4, поэтому осталось найти \(m\). Для этого находим сумму всех элементов матрицы смежности и делим их на 2.

$$ \sum_{i,j} A_{ij} = 0 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 = 10$$

$$ E = \frac{10}{2} = 5$$

В итоге получаем, что \(m\) = 5 и \(n\) = 4. Получив эти значения, мы можем посчитать эффективное сопротивление, воспользуемся формулой (4.2):
$$ R_{14} = \sum_{k=1}^{n-1} \frac{(u_{k1} - u_{k4})^2}{\lambda_k} = \frac{(0.71 - (-0.71))^2}{2} + $$
$$ + \frac{(0.49 - 0.49)^2}{4} + \frac{(0.09 - 0.09)^2}{4} \approx 1.0082$$

Теперь нужно посчитать commute time, для этого воспользуемся формулой (\ref{C_xy_end}):

$$ C_{14} = 2mR_{14} = 2 * 5 * 1.0083 \approx 10.0082$$

Нам осталось посчитать только hitting time, но так как наш граф является маленьким и симметричным, то у нас есть возможность воспользоваться данным вариантом формулы (\ref{C_xy_end}):
$$ C_{14} = H_{14} + H_{41} $$
Для нашего маленького и симметричного графа, это равносильно что:
$$ C_{14} \approx 2H_{14} $$
Следовательно \(H_{14}\) равен:
$$ H_{14}  \approx \frac{C_{14} }{2} \approx \frac{10.0082}{2} \approx 5.0041$$ 

\subsection{Пример 2}
Пример 1 был приведен для демонстрации методологии. Поскольку нахождение вручную данных графа Московского метро практически невозможно, воспользуемся программным методом. Для этого была написана программа, которая воспроизводит вычисления формул: $R_{xy}$, $H_{xy}$, $C_{xy}$.

@d theoretical random walk @{
@< parameters @>
@< calculation of eigenvalues and eigenvectors @>
@< parameters of the iterative process @>
@< neighbourhood lists @>
@< calculate the matrix H @>
@< calculation of results  @>
@< result output @>
@}
@o theoretical_random_walk.m @{@< theoretical random walk @>@}


В этой части кода, мы загружаем матрицу смежности графа из файла. Затем определяем количество вершин и ребер.
@d parameters @{
args = argv();
if numel(args) < 3
        error('Необходимо указать имя файла с матрицей смежности и', 
                'номера двух узлов.');
end
file_path = args{1};
adj_matrix = dlmread(file_path);

n = size(adj_matrix, 1);
m = sum(adj_matrix(:)) / 2;
@}


Здесь мы вычисляем по формулам собственные значения и собственные векторы. Далее извлекаем собственные значения в вектор. И отбрасываем первое нулевое собственное значение и соответствующий ему собственный вектор (они не нужны для дальнейших вычислений).

@d calculation of eigenvalues and eigenvectors @{
degree_matrix = sum(adj_matrix, 2);

laplacian_matrix = diag(degree_matrix) - adj_matrix;

[eigenvectors, eigenvalues_matrix] = eig(laplacian_matrix);
eigenvalues = diag(eigenvalues_matrix);

eigenvalues_nonzero = eigenvalues(2:end);
eigenvectors_nonzero = eigenvectors(:, 2:end);

@}

В этой части код инициализируем матрицу H нулями. Задаем максимальное количество итераций и допустимую ошибку.
@d parameters of the iterative process @{
H = zeros(n, n);

max_iter = 200000;
tol = 1e-16;
@}


Здесь начинаем подсчет времени выполнения. Затем создаем список соседей для каждой вершины. В каждом элементе этого массива neighbors будут храниться массивы индексов соседей соответствующей вершины.

@d neighbourhood lists @{
tic;

neighbors = cell(n, 1);
for i = 1:n
    neighbors{i} = find(adj_matrix(i, :) == 1);
end
@}


В этом блоке в каждой итерации обновляем значения H для всех вершин, используя их соседей. Затем каждые 10000 итераций выводим текущую ошибку. Если ошибка становится меньше заданного порога (tol), процесс останавливается. И в конце записываем время выполнения итерационного процесса.
@d calculate the matrix H @{
for iteration = 1:max_iter
    H_prev = H;
    for u = 1:n
        if degree_matrix(u) > 0
            H(u, :) = 1 + (1 / degree_matrix(u)) * sum(H(neighbors{u}, :), 1);
        end
        H(u, u) = 0;  % Условие H_ii = 0
    end
    if mod(iteration, 10000) == 0
        disp(['Итерация: ', num2str(iteration), ' H - ', num2str(max(max(abs(H - H_prev))))]);
    end
    if max(max(abs(H - H_prev))) < tol
        disp(['Сошлось после ', num2str(iteration), ' итераций']);
        break;
    end
end
elapsed_time = toc;
@}


Здесь мы рассчитаем среднее время прохождения, время возвращения и эффективное сопротивление между заданными вершинами на основе полученных данных.
@d calculation of results @{
i = str2double(args{2});
j = str2double(args{3});

H_ij = H(i, j);

R_ij = sum((eigenvectors_nonzero(i, :) - eigenvectors_nonzero(j, :)).^2 ./ eigenvalues_nonzero');

C_ij = 2 * m * R_ij;
@}

Выводим вычисленные результаты.
@d result output @{
disp(['Среднее время прохода из вершины ', num2str(i), ' в вершину ', num2str(j), ': ', num2str(H_ij)]);
disp(['Среднее время прохода из вершины ', num2str(i), ' в вершину ', num2str(j), ' и обратно: ', num2str(C_ij)]);
disp(['Эффективное сопротивление: ', num2str(R_ij)]);
disp(['Время выполнения программы: ', num2str(elapsed_time), ' секунд']);
@}

 
 Результаты данных вычислений:
 \begin{itemize}
    \item Сошлось после 293492 итераций
    \item Среднее время прохождения из вершин 1 в вершину 442: 17085.752085552034
    \item Среднее время прохождения из вершины 1 в вершину 442 и обратно: 20199.377213668093
    \item Эффективное сопротивление: 16.03125175687944
    \item Время выполнения программы: 2841.8106 секунд
\end{itemize}

\subsection{Пример 3}
Результаты вычислений для линейного графа:
 \begin{itemize}
    \item Сошлось после 2016601 итераций
    \item Среднее время прохождения из вершин 1 в вершину 442: 194480.99999830942
    \item Среднее время прохождения из вершины 1 в вершину 442 и обратно: 388961.9999977657
    \item Эффективное сопротивление: 440.9999999974668
    \item Время выполнения программы: 8452.6199 секунд
\end{itemize}

Результаты вычислительных экспериментов и теоретических расчетов для графа демонстрируют 
высокую степень согласованности, что свидетельствует о правильности применяемых моделей и алгоритмов. 
Тестирование проводилось на графе с четырьмя вершинами, на котором было установлено, что теоретические предсказания совпадают с практическими результатами. 
Кроме того, применение данных методов на лиенйном графе и на графе Московского метро показало, 
что алгоритмы могут работать не только в теоретических условиях, но и с реальной 
транспортной сетью. 
Среднее время первого попадания, прохождения и обхода всего графа, 
а также эффективное сопротивление, полученные в результате тестов, находятся в хорошем 
согласии с теоретическими расчетами. 
Эти три случая подтверждают, что предложенные модели и алгоритмы могут быть успешно 
применены для анализа и прогнозирования поведения более сложных и масштабных транспортных 
сетей.

\backmatter
\chapter{Заключение}

В рамках данной исследовательской работы была рассмотрена задача нахождения резистивного расстояния между узлами электрической цепи, представленной в виде графа. 
В результате проведенных теоретических исследований и разработок удалось достичь следующих результатов:

\begin{enumerate}
    \item \textbf{Математическое моделирование электрических цепей}:
    \begin{itemize}
        \item Электрические цепи были успешно смоделированы с помощью теории графов, где узлы сети представляли вершины графа, а сопротивления между узлами --- веса ребер.
        \item Была установлена взаимосвязь между Законами Кирхгофа и резистивным расстоянием, что позволяет использовать математические методы теории графов для анализа электрических цепей.
    \end{itemize}

    \item \textbf{Вывод резистивного расстояния}:
    \begin{itemize}
        \item Резистивное расстояние между двумя вершинами графа было определено как эффективное сопротивление между соответствующими узлами в электрической цепи, где все сопротивления заменены на единичные.
        \item Была выведена формула для нахождения резистивного расстояния с использованием обобщенной обратной матрицы Лапласиана графа, что позволило упростить вычисления и сделать их более наглядными.
    \end{itemize}

        \item \textbf{Разработка программ}:
    \begin{itemize}
        \item На языке Octave были разработаны алгоритмы для вычисления резистивного расстояния между двумя вершинами графа, а также алгоритм случайного блуждания. Программы обеспечивают универсальность использования, позволяют загружать матрицу смежности из файла и вычислять эффективное сопротивление и метрики случайных блужданий.
        \item Программа была протестирована, результаты тестирования показали ее корректность.
    \end{itemize}

    \item \textbf{Практическое применение}:
    \begin{itemize}
        \item Разработанные модели и программа могут быть использованы для анализа и оптимизации различных сетей, включая электрические, транспортные и коммуникационные сети.
        \item Методика может быть полезна в таких областях, как проектирование электрических цепей, анализ надёжности сетей и оптимизация маршрутов.
    \end{itemize}
\end{enumerate}

Таким образом, проделанная работа позволяет сделать вывод о том, что применение теории графов и 
метода случайных блужданий для анализа электрических цепей является эффективным и перспективным направлением исследований.

 Разработанные алгоритмы и программы могут быть полезны в практике инженеров и исследователей, 
занимающихся анализом и оптимизацией сложных сетей.


\bibliographystyle{gost780u}
\bibliography{rpz}
\end{document}

